[{"categories":["Oracle","Java","SQL"],"content":"هرچند SQL بسیاری از نیازمندی‌های برنامه‌نویسان را در زمینه‌ی کار با داده‌ها برطرف می‌نماید اما در مواقعی که نیاز به پیاده‌سازی توابع پیچیده یا تبدیل انواع خاص و سفارشی بهم داریم نیاز به استفاده از یک زبان‌ برنامه‌نویسی سطح بالا وجود دارد. هرچند استفاده از زبان‌های برنامه‌نویسی دیگر در بانک‌های اطلاعاتی رابطه‌ای مرسوم نیست و حتی در برخی موارد ممکن است کارایی سیستم را کاهش دهد اما اگر در جای درستی استفاده شود مطمئنا باعث بهبود عملکرد کلی سیستم می‌شود. بدین منظور، در بانک اطلاعاتی Oracle قابلیت استفاده از زبان برنامه‌نویسی Java وجود دارد و می‌توان متدهای نوشته شده با این زبان را با SQL ادغام و اجرا نمود.\nبه منظور استفاده از متدهای Java در Oralce چندین روش پیشنهاد می‌شود:\nاستفاده از PL/SQL Wrappers پشتیبانی از JNI استفاده از SQLJ و JDBC استفاده از رابط خط فرمان استفاده از Stub در سمت کلاینت در این مطلب از ساده‌ترین روش یعنی PL/SQL Wrappers برای فراخوانی متدهای Java استفاده می‌نماییم. شما می‌توانید متدهای کامپایل‌شده Java را به همان روشی که توابع و روال‌های ذخیره شده (Stored Procedure) در PL/SQL اجرا می‌شوند، اجرا کنید. در بانک اطلاعاتی Oracle، متدهای Java معمولا از طریق رابط PL/SQL فراخوانی می‌شود. برای فراخوانی یک متد کامپایل‌شده Java، باید آن را از طریق \u0026ldquo;مشخصات فراخوانی\u0026rdquo; (Call Specification) منتشر کنید. مثال زیر نحوه‌ی ایجاد، resolve، بارگذاری و انتشار یک متد ساده کامپایل‌شده Java را نشان می‌دهد که یک رشته را باز می‌گرداند: 1-\tکلاس Hello را به شکل زیر پیاده‌سازی می‌کنیم و آن را با نام Hello.java ذخیره می‌نماییم. توجه داشته باشید که به منظور فراخوانی متدهای Java نیاز است آن‌ها را به صورت static پیاده‌سازی نمایید.\n1public class Hello 2{ 3 public static String world() 4 { 5 return \u0026#34;Hello world\u0026#34;; 6 } 7} 2-\tسپس کلاس مورد نظر را با کامپایلر (Compiler) استاندارد Java، کامپایل می‌نماییم:\n1javac Hello.java با ایجاد این دستور، کامپایلر یک فایل باینری Java (در این مورد Hello.class) را تولید می‌کند. ایده‌ی خوبی است که CLASSPATH را در خط فرمان با دستور javac مشخص کنید، مخصوصا هنگام نوشتن اسکریپت‌های shell یا ایجاد فایل. شما باید مکانی که این کد Java در آن اجرا می‌شود را تعیین نمایید. اگر Hello.class را روی سیستم کلاینت خود اجرا می‌کنید، CLASSPATH را برای تمام کلاس‌های اصلی وابسته که Hello.class برای اجرا نیاز دارد جستجو می‌کند. این جستجو باید منجر به یافتن کلاس‌های وابسته در یکی از موارد زیر شود:\nبه عنوان فایل‌های جداگانه در یک یا چند دایرکتوری، جایی که دایرکتوری‌ها در CLASSPATH مشخص شده‌اند. در فایل‌های jar یا zip، که دایرکتوری‌های حاوی این فایل‌ها در CLASSPATH مشخص شده‌اند. 3-\tدر مورد resolver کلاس Hello تصمیم بگیرید. در این مورد، Hello.class را در سرور بارگذاری کنید، جایی که در بانک اطلاعاتی به عنوان یک شی طرح Java ذخیره می‌شود. هنگامی که متد world را فراخوانی می‌کنید، Oracle JVM کلاس‌های وابسته لازم مانند String را با استفاده از یک resolver مکان‌یابی می‌کند. در این مورد، Oracle JVM از resolver پیش‌فرض استفاده می‌کند. resolver پیش‌فرض این کلاس‌ها را ابتدا در اسکیمای (schema) فعلی و سپس در PUBLIC جستجو می‌کند. تمام کتابخانه‌های کلاس اصلی، از جمله java.lang، در PUBLIC یافت می‌شوند. ممکن است لازم باشد resolverهای مختلفی را مشخص کنید. این امکان وجود دارد که با استفاده از ابزار loadjava، مشکلات را زودتر و نه در زمان اجرا ردیابی کنید.\n4-\tکلاس را با استفاده از ابزار loadjava روی سرور بارگذاری کنید. شما باید نام کاربری و رمز عبور بانک اطلاعاتی مربوطه را نیز مشخص کنید. ابزار loadjava را به صورت زیر اجرا کنید:\n1loadjava -user user/password@ip:1521:database Hello.class با استفاده از ویژگی verbose- در ابزار loadjava می‌توان پیغام‌های مرتبط با بارگذاری کلاس را مشاهده نمود. 5-\tمتد کامپایل‌شده را از طریق مشخصات فراخوانی (Call Specification) منتشر کنید. برای فراخوانی متد مربوطه Java با فراخوانی SQL، باید متد را با مشخصات فراخوانی منتشر کنید. مشخصات فراخوانی آرگومان‌هایی را که متد می‌گیرد و انواع SQL که باز می‌گرداند را تعریف می‌کند. مشخصات فراخوانی امکانی برای پیوند دادن فراخوانی‌های بین زبانی با هم به شیوه‌ای ثابت فراهم می‌کند.\n1CREATE OR REPLACE FUNCTION FUNC_HELLO_WORD RETURN VARCHAR2 AS 2LANGUAGE JAVA NAME \u0026#39;Hello.world () return java.lang.String\u0026#39;; 6-\tتابع مربوطه را به شکل زیر فراخوانی کنید:\n1DECLARE v_Return varchar2(1000); 2BEGIN 3 v_Return := FUNC_HELLO_WORD(); 4 DBMS_OUTPUT.PUT_LINE(\u0026#39;v_Return = \u0026#39; || v_Return); 5END; ","date":"Jan 15, 2023","img":"","permalink":"/posts/oracle-load-java/","series":[],"tags":["Oracle","Java","LoadJava","SQL"],"title":"استفاده از زبان برنامه‌نویسی Java در بانک اطلاعاتی Oracle"},{"categories":["General"],"content":"موفقیت یونی‌کُد در یکپارچه نمودن کدبندی کاراکترها سبب استفاده‌ی گسترده‌ در جهانی‌سازی و بومی‌سازی نرم‌افزارها شده‌است. امروزه اکثر شرکت‌های بزرگ دنیای کامپیوتر از این استاندارد استفاده می‌کنند و همچنین می‌توان گفت که تقریبا تمام برنامه‌های کاربردی جدید با این استاندارد کدگذاری شده‌اند. گسترش استاندارد یونی‌کُد موجب شده فرایند ایجاد وبسایت‌ها و برنامه‌های فارسی زبان بسیار آسان‌تر و کم هزینه‌تر باشد تا تمامی فارسی زبان‌ها هم بتوانند در دنیای اینترنت مطالب خود را عرضه کنند.\nهمانطور که در مطلب \u0026ldquo;یونی‌کُد چیست؟\u0026rdquo; گفته شد هر کاراکتری اعم از اعداد و حروف، یک نقطه کد منحصربه‌فرد در یونی‌کُد دارد. در استاندارد یونی‌کُد نقطه کدهای زبان فارسی و عربی به دلیل تشابه در رسم الخط در یک مجموعه یا بلاک Block قرار داده شده‌اند. نقطه کدهای U+0600 الی U+06FF مربوط به بلاک عربی و فارسی می‌باشد. این لیست را می‌توانید از \u0026ldquo;اینجا\u0026rdquo; دانلود و مشاهده کنید. از آنجا که نقطه کدهای زبان فارسی با نقطه کدهای عربی ترکیب شده‌اند در این مطلب به صورت اختصاصی نقطه کدهای زبان فارسی را بررسی و لیست می‌نماییم. ابتدا نکاتی در مورد زبان فارسی را یادآوری می کنیم: اساس الفبای فارسی با الفبای عربی یکی است، اما الفبای فارسی دارای چهار حرف است که واج‌های متناظر آن‌ها در عربی وجود ندارد، از آن طرف «ة» (تاء مربوط) در الفبای فارسی وجود ندارد. یک خوش‌نویس به نام خواجه ابولمال، سه حرف \u0026ldquo;پ\u0026rdquo;، \u0026ldquo;ژ\u0026rdquo; و \u0026ldquo;چ\u0026rdquo; را به الفبای عربی اضافه کرد و حرف \u0026ldquo;گ\u0026rdquo; نیز پس از چندی دگرگونی، به شکل کنونی درآمد. برخی از حروف فارسی با حروف متناظر خود در عربی متفاوت هستند؛ مثلاً حرف «ک» در فارسی در حالت پایانی یا به‌طور تنها، با سرکش نوشته می‌شود درحالی‌که این حرف در عربی در این دو حالت بدون سرکش به صورت «ك» نوشته می‌شود. همچنین حرف «ی» در حالت پایانی در فارسی بدون نقطه است، اما در عربی با دونقطه در پایین («ي») نوشته می‌شود. همزه (ء) در میان حروف سی‌ودو گانه‌ی الفبای فارسی شکلی از ملحقات حرف «الف» (صامت) است. شکل جدای آن (ء) و در حالت‌های گوناگون با ترکیب دیگر اشکال به صورت (آ - أ - ئ - ؤ) نوشته می‌شود. برای اطلاعات بیشتر به مطلب \u0026ldquo;املای درست همزه در فارسی\u0026rdquo; مراجعه نمایید. حروف فارسی به ترتیب زیر در استاندارد یونی‌کُد وجود دارند: حرف نقطه کد توضیحات ء U+0621 Arabic Letter Hamza آ U+0622 Arabic Letter Alef with Madda Above أ U+0623 Arabic Letter Alef with Hamza Above ؤ U+0624 Arabic Letter Waw with Hamza Above إ U+0625 Arabic Letter Alef with Hamza Below ئ U+0626 Arabic Letter Yeh with Hamza Above ا U+0627 Arabic Letter Alef ب U+0628 Arabic Letter Beh پ U+067E Arabic Letter Peh ت U+062A Arabic Letter Teh ث U+062B Arabic Letter Theh ج U+062C Arabic Letter Jeem چ U+0686 Arabic Letter Tcheh ح U+062D Arabic Letter Hah خ U+062E Arabic Letter Khah د U+062F Arabic Letter Dal ذ U+0630 Arabic Letter Thal ر U+0631 Arabic Letter Reh ز U+0632 Arabic Letter Zain ژ U+0698 Arabic Letter Jeh س U+0633 Arabic Letter Seen ش U+0634 Arabic Letter Sheen ص U+0635 Arabic Letter Sad ض U+0636 Arabic Letter Dad ط U+0637 Arabic Letter Tah ظ U+0638 Arabic Letter Zah ع U+0639 Arabic Letter Ain غ U+063A Arabic Letter Ghain ف U+0641 Arabic Letter Feh ق U+0642 Arabic Letter Qaf ک U+06A9 Arabic Letter Keheh گ U+06AF Arabic Letter Gaf ل U+0644 Arabic Letter Lam م U+0645 Arabic Letter Meem ن U+0646 Arabic Letter Noon و U+0648 Arabic Letter Waw ه U+0647 Arabic Letter Heh ی U+06CC Arabic Letter Farsi Yeh اعداد فارسی نیز به ترتیب زیر در استاندارد یونی‌کُد وجود دارند: عدد نقطه کد توضیحات ۰ U+06F0 Extended Arabic-Indic Digit Zero ۱ U+06F1 Extended Arabic-Indic Digit One ۲ U+06F2 Extended Arabic-Indic Digit Two ۳ U+06F3 Extended Arabic-Indic Digit Three ۴ U+06F4 Extended Arabic-Indic Digit Four ۵ U+06F5 Extended Arabic-Indic Digit Five ۶ U+06F6 Extended Arabic-Indic Digit Six ۷ U+06F7 Extended Arabic-Indic Digit Seven ۸ U+06F8 Extended Arabic-Indic Digit Eight ۹ U+06F9 Extended Arabic-Indic Digit Nine ","date":"Sep 1, 2020","img":"","permalink":"/posts/unicode-farsi/","series":[],"tags":["Unicode","Persian","Farsi"],"title":"یونی‌کُد فارسی"},{"categories":["DotNet","CSharp","Float"],"content":"برای مقایسه‌ی دو عدد ممیز شناور نیاز به یک مقدار انحراف مجاز (tolerance) وجود دارد تا مشخص شود دو عدد تا چند رقم اعشار باید باهم مقایسه شوند.\nمقادیر ممیز شناور ذاتاً دقیق نیستند، و مقایسه‌ی دقیق آن‌ها ممکن است نتیجه‌ی درستی به همراه نداشته باشد. با استفاده از تعریف یک مقدار انحراف مجاز (tolerance) و بررسی اختلاف دو عدد با مقدار انحراف مجاز، می‌توان دو مقدار ممیز شناور را به درستی باهم مقایسه نمود:\n1public static class FloatUtils 2{ 3 public static bool AreFloatsEqual(float a, float b, float tolerance) 4 { 5 return Math.Abs(a - b) \u0026lt;= tolerance; 6 } 7 8 public static bool IsFloatGreaterThan(float a, float b, float tolerance) 9 { 10 return (a - b) \u0026gt; tolerance; 11 } 12 13 public static bool IsFloatGreaterThanOrEqual(float a, float b, float tolerance) 14 { 15 return ((a - b) \u0026gt; tolerance) || Math.Abs(a - b) \u0026lt;= tolerance; 16 } 17 18 public static bool IsFloatLessThan(float a, float b, float tolerance) 19 { 20 return (b - a) \u0026gt; tolerance; 21 } 22 23 public static bool IsFloatLessThanOrEqual(float a, float b, float tolerance) 24 { 25 return ((b - a) \u0026gt; tolerance) || Math.Abs(a - b) \u0026lt;= tolerance; 26 } 27} به منظور تست کدهای بالا می‌توان از پیاده‌سازی زیر استفاده نمود:\n1using System; 2 3public class Program 4{ 5 public static void Main() 6 { 7 float a = 0.1f; 8 float b = 0.1000001f; 9 float tolerance = 0.00001f; 10 11 bool areEqual = FloatUtils.AreFloatsEqual(a, b, tolerance); 12 bool isGreaterThan = FloatUtils.IsFloatGreaterThan(a, b, tolerance); 13 bool isLessThan = FloatUtils.IsFloatLessThan(a, b, tolerance); 14 15 Console.WriteLine($\u0026#34;Are the floats equal? {areEqual}\u0026#34;); 16 Console.WriteLine($\u0026#34;Is a greater than b? {isGreaterThan}\u0026#34;); 17 Console.WriteLine($\u0026#34;Is a less than b? {isLessThan}\u0026#34;); 18 } 19} ","date":"Aug 4, 2020","img":"","permalink":"/posts/compare-floats/","series":[],"tags":["DotNet","CSharp","Float"],"title":"مقایسه دو مقدار ممیز شناور در CSharp"},{"categories":["SQLServer","SQL"],"content":"برای تهیه‌ی صورت حساب بانکی (گردش حساب) در SQL روش‌های مختلفی وجود دارد که ما در این مطلب یکی از روش‌های آن را پیاده‌سازی می‌کنیم.\nبه عنوان یک مثال جدولی برای نگهداری تراکنش‌ها ایجاد می‌نماییم:\n1CREATE TABLE [Transactions] 2([Row] integer, [Type] integer, [Amount] DECIMAL(18,0)) سپس آن را با مقادیر زیر مقداردهی می‌کنیم:\n1INSERT INTO [Transactions] ([Row], [Type], [Amount]) 2VALUES (1, 1, 1000) 3 4INSERT INTO [Transactions] ([Row], [Type], [Amount]) 5VALUES (2, 1, 2000) 6 7INSERT INTO [Transactions] ([Row], [Type], [Amount]) 8VALUES (3, -1, 1000) 9 10INSERT INTO [Transactions] ([Row], [Type], [Amount]) 11VALUES (4, 1, 3000) سه متغیر به نام‌های SumCredit، SumDebit و Balance را به عنوان جمع بستانکار از قبل، جمع بدهکار از قبل و مانده از قبل تعریف می‌کنیم. در صورتی که همه تراکنش‌ها در یک جدول است و جدول دیگری برای تراکنش‌های قبلی نداریم مقدار این سه متغیر را می‌توان برابر صفر قرار داد یا آن‌ها را با صفر جایگزین نمود.\n1DECLARE @SumCredit DECIMAL(18,0); 2SET @SumCredit = 8000; 3 4DECLARE @SumDebit DECIMAL(18,0); 5SET @SumDebit = 2000; 6 7DECLARE @Balance DECIMAL(18,0); 8SET @Balance = 5000; در آخر هم به منظور نمایش صورت حساب به روش زیر عمل می کنیم:\n1SELECT 2\t[Row] AS Row, 3\t[Type] AS Type, 4\t[Amount] AS Amount, 5\t((SUM(([Type]*[Amount])*(-1)) OVER (ORDER BY [Row])) + @Balance) AS Balance, 6\t((SUM(CASE WHEN [Type] = -1 THEN [Amount] ELSE 0 END) OVER (ORDER BY [Row])) + @SumCredit) AS Credit, 7\t((SUM(CASE WHEN [Type] = 1 THEN [Amount] ELSE 0 END) OVER (ORDER BY [Row])) + @SumDebit) AS Debit 8FROM [Transactions] ","date":"Jul 2, 2020","img":"","permalink":"/posts/sql-server-turnover/","series":[],"tags":["SQLServer","SQL","Turn Over","Balance Sheet"],"title":"گزارش صورت حساب در SQL"},{"categories":["Shetab"],"content":"سامانه‌ی شتاب به عنوان تنها سوئیچ ملی بین بانکی کشور، سیستمی مبتنی بر کارت‌ بوده و وظیفه تبادل تراکنش‌های بین بانکی و اعمال مقررات بانک مرکزی به عنوان مقام ناظر را بر عهده دارد و سطح گستردگی این سامانه شامل کلیه بانک‌های کشور است که با اتصال به چند سوئیچ برون‌مرزی، کل تراکنش‌های کارتی کشور را پوشش می‌دهد.\nسامانه‌ی شتاب جهت تبادل پیام‌ها و تراکنش‌های مالی از استاندارد ISO8583 استفاده کرده و قابلیت پشتیبانی از سه ویرایش این استاندارد که در سال‌های 1987، 1993 و 2003 ارائه گردیده است را دارد. بانک مرکزی در سال 1392 با ارائه نسخه 7 شتاب بانک‌ها را ملزم به استفاده از ویرایش 2003 این استاندارد کرده است. شتاب وظیفه انتقال امن اطلاعات و داده‌های مربوط به تراکنش‌های ‌مالی و غیرمالی به بانک‌های صادرکننده و یا پذیرنده را دارد. این مرکز با استفاده از سخت افزارها، نرم افزارها و شبکه‌ی ارتباطی خود، پیام‌ها و داده‌های اخذ شده از اعضا را پذیرش کرده، آن‌ها را ثبت، مسیریابی و به بانک‌های صادرکننده یا پذیرنده ارسال می‌نماید. نتیجه این اقدامات دریافت خدمات مبتنی بر کارت توسط دارندگان کارت بانک‌ها از تجهیزات سایر بانک‌ها می‌باشد. شتاب برای نظارت بیشتر بر شبکه‌ی بانکی با ارتباط با مرکز کنترل و نظارت اعتباری (مکنا) کلیه سوابق مشتریان و قوانین بالا دستی را کنترل و بر تراکنش‌های تبادلی در این شبکه نظارت دارد.\n","date":"Jun 3, 2020","img":"","permalink":"/posts/shetab-info/","series":[],"tags":["شتاب","Shetab"],"title":"سامانه شتاب"},{"categories":["SQLServer","SQL"],"content":"یکی از موارد پُرکاربرد در مهندسی معکوس نرم‌افزارهای دارای بانک اطلاعاتی جستجوی یک مقدار در کل جدول‌های یک بانک اطلاعاتی است.\nبه این منظور می‌توان از کد زیر استفاده نمود:\n1DECLARE @SearchStr nvarchar(100) 2SET @SearchStr = \u0026#39;## YOUR STRING HERE ##\u0026#39; 3 4CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) 5 6SET NOCOUNT ON 7 8DECLARE @TableName nvarchar(256), 9\t@ColumnName nvarchar(128), 10\t@SearchStr2 nvarchar(110) 11 12SET @TableName = \u0026#39;\u0026#39; 13 14SET @SearchStr2 = QUOTENAME(\u0026#39;%\u0026#39; + @SearchStr + \u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;) 15 16WHILE @TableName IS NOT NULL 17BEGIN 18 SET @ColumnName = \u0026#39;\u0026#39; 19 SET @TableName = 20 ( 21 SELECT MIN(QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME)) 22 FROM INFORMATION_SCHEMA.TABLES 23 WHERE TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 24 AND QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) \u0026gt; @TableName 25 AND OBJECTPROPERTY( 26 OBJECT_ID( 27 QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) 28 ), \u0026#39;IsMSShipped\u0026#39; 29 ) = 0 30 ) 31 32 WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) 33 BEGIN 34 SET @ColumnName = 35 ( 36 SELECT MIN(QUOTENAME(COLUMN_NAME)) 37 FROM INFORMATION_SCHEMA.COLUMNS 38 WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) 39 AND TABLE_NAME = PARSENAME(@TableName, 1) 40 AND DATA_TYPE IN (\u0026#39;char\u0026#39;, \u0026#39;varchar\u0026#39;, \u0026#39;nchar\u0026#39;, \u0026#39;nvarchar\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;decimal\u0026#39;) 41 AND QUOTENAME(COLUMN_NAME) \u0026gt; @ColumnName 42 ) 43 44 IF @ColumnName IS NOT NULL 45 BEGIN 46 INSERT INTO #Results 47 EXEC 48 ( 49 \u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39; + @TableName + \u0026#39;.\u0026#39; + @ColumnName + \u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39; + @ColumnName + \u0026#39;, 3630) FROM \u0026#39; + @TableName + \u0026#39; (NOLOCK) \u0026#39; + 50 \u0026#39; WHERE \u0026#39; + @ColumnName + \u0026#39; LIKE \u0026#39; + @SearchStr2 51 ) 52 END 53 END 54END 55 56SELECT ColumnName, ColumnValue FROM #Results 57 58DROP TABLE #Results همچنین می‌توان به منظور قابلیت استفاده مجدد، کد بالا را به صورت Stored Procedure نیز پیاده‌سازی نمود:\n1CREATE PROC SearchAllTables 2( 3 @SearchStr nvarchar(100) 4) 5AS 6BEGIN 7 CREATE TABLE #Results (ColumnName nvarchar(370), ColumnValue nvarchar(3630)) 8 9 SET NOCOUNT ON 10 11 DECLARE @TableName nvarchar(256), 12\t@ColumnName nvarchar(128), 13\t@SearchStr2 nvarchar(110) 14\t15 SET @TableName = \u0026#39;\u0026#39; 16 SET @SearchStr2 = QUOTENAME(\u0026#39;%\u0026#39; + @SearchStr + \u0026#39;%\u0026#39;,\u0026#39;\u0026#39;\u0026#39;\u0026#39;) 17 18 WHILE @TableName IS NOT NULL 19 BEGIN 20 SET @ColumnName = \u0026#39;\u0026#39; 21 SET @TableName = 22 ( 23 SELECT MIN(QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME)) 24 FROM INFORMATION_SCHEMA.TABLES 25 WHERE TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39; 26 AND QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) \u0026gt; @TableName 27 AND OBJECTPROPERTY( 28 OBJECT_ID( 29 QUOTENAME(TABLE_SCHEMA) + \u0026#39;.\u0026#39; + QUOTENAME(TABLE_NAME) 30 ), \u0026#39;IsMSShipped\u0026#39; 31 ) = 0 32 ) 33 34 WHILE (@TableName IS NOT NULL) AND (@ColumnName IS NOT NULL) 35 BEGIN 36 SET @ColumnName = 37 ( 38 SELECT MIN(QUOTENAME(COLUMN_NAME)) 39 FROM INFORMATION_SCHEMA.COLUMNS 40 WHERE TABLE_SCHEMA = PARSENAME(@TableName, 2) 41 AND TABLE_NAME = PARSENAME(@TableName, 1) 42 AND DATA_TYPE IN (\u0026#39;char\u0026#39;, \u0026#39;varchar\u0026#39;, \u0026#39;nchar\u0026#39;, \u0026#39;nvarchar\u0026#39;, \u0026#39;int\u0026#39;, \u0026#39;decimal\u0026#39;) 43 AND QUOTENAME(COLUMN_NAME) \u0026gt; @ColumnName 44 ) 45 46 IF @ColumnName IS NOT NULL 47 BEGIN 48 INSERT INTO #Results 49 EXEC 50 ( 51 \u0026#39;SELECT \u0026#39;\u0026#39;\u0026#39; + @TableName + \u0026#39;.\u0026#39; + @ColumnName + \u0026#39;\u0026#39;\u0026#39;, LEFT(\u0026#39; + @ColumnName + \u0026#39;, 3630) FROM \u0026#39; + @TableName + \u0026#39; (NOLOCK) \u0026#39; + 52 \u0026#39; WHERE \u0026#39; + @ColumnName + \u0026#39; LIKE \u0026#39; + @SearchStr2 53 ) 54 END 55 END 56 END 57 58 SELECT ColumnName, ColumnValue FROM #Results 59 DROP TABLE #Results 60END ","date":"Feb 9, 2020","img":"","permalink":"/posts/sql-server-search-in-tables/","series":[],"tags":["SQLServer","SQL"],"title":"جستجو در همه جدول‌ها در SQL Server"},{"categories":["DotNet","CSharp","SQLServer","SQL"],"content":"SQL Server به منظور ارتقا در مدل برنامه‌نویسی بانک اطلاعاتی خود از نسخه 2005 تکنولوژی SQL CLR را معرفی نمود. این تکنولوژی همچنین با اسامی CLR Integrated ،CLR Enabled و CLR Embedded نیز شناخته می‌شود. هدف آن این است که شما بتوانید اشیاء بانک اطلاعاتی از قبیل روال‌های ذخیره شده (Stored Procedure) ، توابع (Function) و تریگرها (Trigger) را با استفاده از CSharp و یا VB ایجاد کرده و آن را در SQL Server مورد استفاده قرار دهید.\nتکنولوژی SQL CLR با میزبانی کردن از (dotNET Common Language Runtime) یا همان محیط زمان اجرای dotNET در SQL Server، به مدیران بانک اطلاعاتی اجازه می‌دهد تا از قابلیت‌های موجود در dotNET برای تعریف اشیاء بانک اطلاعاتی استفاده کنند. این قابلیت توسط فضاهای نام System.Data ،System.Data.Sql و Microsoft.SqlServer.Server که در اسمبلی (assembly) System.Data.dll در dotNET قرار داده شده‌اند، پشتیبانی می‌گردند. ایجاد اشیاء بانک اطلاعاتی با استفاده از امکان SQL CLR، طی مراحل زیر ممکن می‌گردند:\nپیاده‌سازی کدها در CSharp یا VB در dotNET و کامپایل آن بارگذاری و اجرای کد کامپایل شده در مرحله قبل در SQL Server فعال سازی امکان SQL CLR در بانک اطلاعاتی ایجاد اسمبلی از کد مزبور در بانک اطلاعاتی ایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل پیاده‌سازی کدها در CSharp یا VB در dotNET و کامپایل آن به عنوان مثال کد مورد نظر خود را در کلاسی با نام StoredProcedures و در تابع SP1 نوشته و آن را کامپایل می‌کنیم. کد کامپایل شده را (StoredProcedures.dll) باید در مرحله بعد در SQL Server بارگذاری کنیم. البته کد زیر یک مثال hello world بوده و تنها به منظور آشنایی با نحوه انجام کار می‌باشد. از تمامی قابلیت‌ها و کلاس‌های موجود در dotNET می‌توان در این کلاس استفاده نمود.\n1using System; 2using System.Data; 3using Microsoft.SqlServer.Server; 4using System.Data.SqlTypes; 5 6public class StoredProcedures 7{ 8 [Microsoft.SqlServer.Server.SqlProcedure] 9 public static void SP1() 10 { 11 SqlContext.Pipe.Send(\u0026#34;Hello world!\\n\u0026#34;); 12 } 13} فعال‌سازی امکان CLR SQL در بانک اطلاعاتی امکان CLR SQL در SQL Server به صورت پیش فرض غیرفعال است و برای فعال‌سازی آن باید کد زیر را اجرا کرد:\n1sp_configure \u0026#39;show advanced options\u0026#39;, 1 2RECONFIGURE 3GO 4 5sp_configure \u0026#39;clr enabled\u0026#39;, 1 6RECONFIGURE 7GO 8 9sp_configure \u0026#39;show advanced options\u0026#39;, 0 10RECONFIGURE 11GO برای غیرفعال‌سازی هم کد زیر را باید اجرا نمود:\n1sp_configure \u0026#39;show advanced options\u0026#39;, 1 2RECONFIGURE 3GO 4 5sp_configure \u0026#39;clr enabled\u0026#39;, 0 6RECONFIGURE 7GO 8 9sp_configure \u0026#39;show advanced options\u0026#39;, 0 10RECONFIGURE 11GO برای اینکه فعال یا غیرفعال بودن SQL CLR را در SQL SERVER بررسی نماییم باید کد زیر را اجرا نمود:\n1SELECT name 2 ,CAST(value AS int) AS value_configured 3 ,CAST(value_in_use AS int) AS value_in_use 4FROM sys.configurations 5WHERE name = \u0026#39;clr enabled\u0026#39; ایجاد اسمبلی در بانک اطلاعاتی گام بعدی ایجاد اسمبلی در بانک اطلاعاتی از روی کد کامپایل شده است.\n1CREATE ASSEMBLY QClrIntegration 2\tFROM \u0026#39;H:\\Clr\\StoredProcedures.dll\u0026#39; 3\tWITH Permission_set = safe 4GO با توجه به کدی که نوشته‌ایم و برای کنترل دسترسی کد CLR به دیگر کدها از PERMISSION_SET استفاده می‌گردد:\nویژگی SAFE به اسمبلی‌ها اجازه می‌دهد که تنها محاسبات محلی و دسترسی به فایل‌های محلی را داشته باشد. ویژگی EXTERNAL_ACCESS مشابه ویژگی قبلی با این تفاوت که اسمبلی می‌تواند به منابع شبکه دسترسی داشته باشد. ویژگی UNSAFE اجازه دسترسی نامحدود به منابع و کدهای غیر از dotNet و مدیریت نشده (Unmanaged Code) را هم می‌دهد. برای استفاده از ویژگی UNSAFE باید ویژگی اعتماد (trustworthy) را در بانک اطلاعاتی فعال نمود. این ویژگی مشخص می‌کند که بانک اطلاعاتی به کدهای بیرونی اعتماد دارد (البته توصیه نمی‌شود). در غیر این صورت با فعال‌سازی خصوصیت UNSAFE خطا اعلام می‌شود.\n1ALTER DATABASE DB_NAME 2\tSET trustworthy ON 3GO\tبه طور کلی فعال کردن استفاده از SQL CLR سطح حملات به SQL Server را وسیع‌تر می‌کند و آن را از نظر اسمبلی‌های غیر عمدی و مخرب در معرض خطر قرار می‌دهد. با توجه به ضرورت استفاده از SQL CLR بسیاری از چک لیست‌های امنیتی فقط اسمبلی‌های ایجاد شده با دسترسی SAFE را مجاز می‌دانند و اسمبلی‌های ایجاد شده با دسترسی‌های UNSAFE و EXTERNAL_ACCESS را خطرناک می‌شمارند.\nایجاد شی بانک اطلاعاتی از اسمبلی مرحله قبل حال می‌توان از اسمبلی ایجاد شده در مرحله قبل برای ایجاد روال ذخیره شده (Stored Procedure) و یا تابع (Function) مورد نظر استفاده نمود. چون در مرحله‌ی قبل ما کلاسی از نوع Stored Procedure ایجاد کردیم، در SQL Server نیز برای استفاده از آن یک روال ذخیره شده ایجاد می‌کنیم.\n1CREATE PROCEDURE hello 2AS 3EXTERNAL NAME helloworld.StoredProcedures.SP1 4GO با اجرای این روال ذخیره شده، کد نوشته شده در تابع sp1 اجرا می‌گردد:\n1EXEC hello 2 3-- Hello world! برای حذف ابتدا باید شی‌هایی که ارجاعی از اسمبلی حذف و سپس خود اسمبلی حذف گردد:\n1DROP PROCEDURE hello 2GO 3 4DROP ASSEMBLY helloworld 5GO ","date":"Feb 7, 2020","img":"","permalink":"/posts/sql-server-clr/","series":[],"tags":["SQLServer","SQL","CLR","CSharp","DotNet","SQL CLR","CLR Integrated","CLR Embedded"],"title":"استفاده از CLR در SQL Server"},{"categories":["DotNet","CSharp"],"content":"برای ایجاد و استفاده از UUID در زبان برنامه‌نویسی CSharp از ساختار Guid موجود در کتابخانه System استفاده می‌شود.\nبرای ایجاد که یک Guid در زبان برنامه‌نویسی CSharp می توان از کد زیر استفاده نمود:\n1public static Guid NewGuid() 2{ 3 return Guid.NewGuid(); 4} guid ایجاد شده در این روش از نوع و نسخه چهارم UUID است و به صورت تصادفی تولید می‌شود. برای تولید guid به صورت ترتیبی می‌توان از کد زیر استفاده نمود:\n1public static Guid NewSequentialGuid() 2{ 3 var uid = Guid.NewGuid().ToByteArray(); 4 var binDate = BitConverter.GetBytes(DateTime.UtcNow.Ticks); 5 6 var secuentialGuid = new byte[uid.Length]; 7 8 secuentialGuid[0] = uid[0]; 9 secuentialGuid[1] = uid[1]; 10 secuentialGuid[2] = uid[2]; 11 secuentialGuid[3] = uid[3]; 12 secuentialGuid[4] = uid[4]; 13 secuentialGuid[5] = uid[5]; 14 secuentialGuid[6] = uid[6]; 15 16 // set the first part of the 8th byte to \u0026#39;1100\u0026#39; so 17 // later we\u0026#39;ll be able to validate it was generated by us 18 19 secuentialGuid[7] = (byte)(0xc0 | (0xf \u0026amp; uid[7])); 20 21 // the last 8 bytes are sequential, 22 // it minimizes index fragmentation 23 // to a degree as long as there are not a large 24 // number of Secuential-Guids generated per millisecond 25 26 secuentialGuid[9] = binDate[0]; 27 secuentialGuid[8] = binDate[1]; 28 secuentialGuid[15] = binDate[2]; 29 secuentialGuid[14] = binDate[3]; 30 secuentialGuid[13] = binDate[4]; 31 secuentialGuid[12] = binDate[5]; 32 secuentialGuid[11] = binDate[6]; 33 secuentialGuid[10] = binDate[7]; 34 35 return new Guid(secuentialGuid); 36} برای بررسی رشته‌ای که حاوی guid است به ساختار guid می‌توان از کد زیر استفاده نمود:\n1public static bool IsGuid(string guidString) 2{ 3 return Guid.TryParse(guidString, out _); 4} برای بررسی اینکه آیا مقدار guid مورد نظرتان یک guid خالی است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsEmptyGuid(Guid guid) 2{ 3 return guid == Guid.Empty; 4} ","date":"Feb 6, 2020","img":"","permalink":"/posts/uuid-guid-csharp/","series":[],"tags":["UUID","GUID","CSharp","DotNet"],"title":"کار با UUID در CSharp"},{"categories":["DotNet","CSharp"],"content":"برای کار با آدرس‌های IPv4 و IPv6 در CSharp از کتابخانه System.Net و کلاس IPAddress استفاده می‌شود.\nبه منظور اعتبارسنجی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static bool IsValidIp(string address) 2{ 3 return IPAddress.TryParse(address, out _); 4} به منظور تشخیص نسخه‌ی آدرس‌های IP می‌توان از کد زیر استفاده نمود:\n1public static IpVersion GetIpVersion(string address) 2{ 3 if (IPAddress.TryParse(address, out var ipAddress)) 4 { 5 if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) 6 { 7 return IpVersion.IPv4; 8 } 9 else if(ipAddress.AddressFamily == System.Net.Sockets.AddressFamily.InterNetworkV6) 10 { 11 return IpVersion.IPv6; 12 } 13 } 14 15 return IpVersion.Unknown; 16} 17\t18public enum IpVersion 19{ 20 Unknown = -1, 21 IPv4, 22 IPv6 23} آدرس Loopback یک آدرس IP ویژه است که برای آزمایش کارت‌های شبکه، ارتباطات و انتقال در یک کارت شبکه محلی و برنامه‌های کاربردی استفاده می‌شود. این آدرس IP مربوط به Loopback Interface نرم‌افزار کارت شبکه است که هیچ سخت‌افزاری با آن ارتباط ندارد و نیازی به اتصال فیزیکی به شبکه ندارد. برای تشخیص اینکه یک IP از نوع Loopback است یا خیر می‌توان از کد زیر استفاده نمود:\n1public static bool IsLoopback(string address) 2{ 3 if (address == \u0026#34;localhost\u0026#34;) 4 return true; 5 6 if (IPAddress.TryParse(address, out var ipAddress)) 7 { 8 if (ipAddress == IPAddress.Loopback || ipAddress == IPAddress.IPv6Loopback) 9 return true; 10 } 11 12 return false; 13} ","date":"Jan 4, 2020","img":"","permalink":"/posts/ip-csharp/","series":[],"tags":["IP","IPHelper","CSharp","DotNet"],"title":"کار با آدرس‌های IP در CSharp"},{"categories":["SQLServer","SQL"],"content":"با توجه به نسخه SQL Server روش جستجو و بازگرداندن لیستی از تمام جدول‌های ایجاد شده توسط کاربر کمی متفاوت است. در این مطلب به طور خلاصه پرس‌و‌جوهایی را بررسی خواهیم کرد که می‌توانند برای بازیابی لیست جدول‌ها در همه نسخه‌ها استفاده شوند.\nنسخه 2000 برای نسخه‌های قدیمی‌تر SQL Server (مانند SQL Server 2000، اگرچه این روش در SQL Server 2005 برای سازگاری با نسخه‌های قبلی نیز پشتیبانی می‌شود)، باید از یک View به نام SYS.SYSOBJECTS استفاده نمایید. این View شامل یک ردیف برای هر شی می‌باشد که در بانک اطلاعاتی ایجاد شده است، از جمله Viewها، stored procedureها و جدول‌ها. جدول‌هایی که کاربر ایجاده کرده است نیز قابل تفکیک از جدول‌های سیستمی هستند.\nدر SYSOBJECTS ستون‌های دیگری نیز وجود دارد زیرا باید اطلاعاتی در مورد هر چیزی که در طول زمان به بانک اطلاعاتی اضافه شده است را در خود نگهداری نماید. بنابراین، برای یافتن لیستی از جدول‌های ایجاد شده توسط کاربر (و تفکیک آن از جدول‌های سیستم)، باید نتایجی را پیدا کنیم که در آن ستون xtype (که نوع شی را برای آن ردیف مشخص می‌کند) برابر با مقدار U است که به معنای جدول‌های کاربر است. دستور TSQL حاصل باید به شکل زیر باشد:\n1SELECT 2 * 3FROM 4 SYSOBJECTS 5WHERE 6 xtype = \u0026#39;U\u0026#39;; 7GO از آنجایی که SYSOBJECTS بخشی از فضای نام SYS است، هنگام پرس‌و‌جو از SYSOBJECTS، تعیین اینکه SYSOBJECTS بخشی از فضای نام سراسری SYS است، غیر ضروری است، بنابراین می‌توانیم آن را همانطور که در مثال بالا نشان داده شده است حذف نماییم.\nمثال بالا لیستی از نتایج تمامی جدول‌ها ایجاد شده توسط کاربر را باز می‌گرداند. از آنجایی که تعداد ستون‌‌هایی که هنگام پرس‌و‌جو از همه ستون‌ها بازگردانده می‌شود بسیار زیاد است، ممکن است بخواهید نتایج را تنها با مشاهده ستون نام و cdate (تاریخ ایجاد) محدود کنید:\n1SELECT 2 name, 3 crdate 4FROM 5 SYSOBJECTS 6WHERE 7 xtype = \u0026#39;U\u0026#39;; 8GO نسخه 2005 به بالا فهرست کردن نام تمام جدول‌ها در SQL Server در نسخه‌های 2005 به بالا با استفاده از یک View به نام INFORMATION_SCHEMA امکان‌پذیر است که به طور خودکار در SQL Server ساخته می‌شود. این View به شما این امکان را می‌دهد که به راحتی طیف گسترده‌ای از metadata از اشیاء موجود در SQL Server را مشاهده نمایید از جمله اطلاعاتی در مورد ستون‌ها، stored procedureها، و حتی جدول‌ها. در هنگام استفاده از این View چهار ستون بازگردانده می‌شود، که مهمترین ستون آن TABLE_TYPE است که تعیین می‌کند موجودیت آن سطر یک جدول یا یک View است.\nبرای برگرداندن همه جدول‌ها و Viewها در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 INFORMATION_SCHEMA.TABLES; 5GO برای برگرداندن همه جدول‌ها و Viewهای یک بانک اطلاعاتی در یک پرس‌و‌جو، عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 databaseName.INFORMATION_SCHEMA.TABLES; 5GO اگر می‌خواهید فقط جدول‌های کاربر را مشاهده نمایید عبارت TSQL زیر را اجرا کنید:\n1SELECT 2 * 3FROM 4 databaseName.INFORMATION_SCHEMA.TABLES 5WHERE 6 TABLE_TYPE = \u0026#39;BASE TABLE\u0026#39;; 7GO ","date":"Aug 1, 2019","img":"","permalink":"/posts/sql-server-show-all-tables/","series":[],"tags":["SQLServer","SQL"],"title":"نمایش لیست همه جدول‌ها در SQL Server"},{"categories":["General","Design Patterns"],"content":"در طول زمان برنامه‌نویسان برای توسعه‌ی نرم‌افزارها با مشکلات مختلفی مواجه می‌شدند. بسیاری از این مشکلات مستقل از زبان‌های برنامه‌نویسی و مشابه هم بودند. بنابراین برای حل این مشکلات راه‌حل‌های مختلفی ارائه شد که به بهترین روش حل و رفع این مشکلات الگوهای طراحی یا Design Pattern می‌گویند. به عبارت دیگر مجموعه‌‌‌ای از بهترین راه‌‌حل‌های مشکلات متداول در فرآیند برنامه‌نویسی نرم‌افزار را الگوهای طراحی می‌نامند. الگوهای طراحی برای حل مشکلات رایج در برنامه‌نویسی شی‌گرا به وسیله‌ی برنامه‌نویسانی باتجربه توسعه داده شده‌اند. الگوهای طراحی جزو معماری‌های نرم‌افزاری نیستند و فقط شیوه‌ای صحیح از کدنویسی شی‌گرا را ارائه می‌دهند. بنابراین این الگوها فقط در قلمرو کدنویسی شی‌گرا وارد می‌شوند و مستقل از زبان‌های برنامه‌نویسی هستند.\nالگوهای طراحی اولین بار توسط کریستوف الکساندر (Christopher Alexander) ارائه شدند. کریستوف الکساندر از الگوهای طراحی تحت عنوان راه‌حل‌هایی برای مشکلاتی یاد می‌کرد که به صورت متداول در فرآیند برنامه‌نویسی رخ می‌دهند. مبحث الگوهای طراحی در سال 1994 در کتاب Design Patterns: Elements of Reusable Object-Oriented Software توسط یک گروه چهار نفره ملقب به Gang of Four یا به اختصار GOF مطرح شد. در این کتاب ۲۳ الگوی طراحی کلاسیک نرم‌افزار با زبان‌های شی‌گرا مطرح در آن زمان ++C و Smalltalk مورد بحث قرار گرفته است. چهار نویسنده‌ی این کتاب، اریک گاما (Erich Gamma)، ریچارد هلم (Richard Helm)، رالف جانسون (Ralph Johnson) و جان ولیزدس (John Vlissides) هستند. این کتاب تا تاریخ آوریل ۲۰۰۷، 36 بار تجدید چاپ شده ‌است. طبقه‌بندی الگوهای طراحی از آنجا که الگوهای طراحی فراوانی وجود دارد نیاز به شیوه‌ای جهت سازماندهی آن‌ها وجود دارد. در این کتاب الگوهای طراحی به گونه‌ای طبقه‌بندی شده‌اند که برنامه‌نویسان به راحتی به خانواده‌های الگوهای مربوطه ارجاع نمایند و الگوی مناسب را انتخاب کنند. همچنین این طبقه‌بندی به یادگیری سریع‌تر الگوهای موجود کمک می‌کند. براساس دو ضابطه الگوهای طراحی طبقه‌بندی می شوند: 1- الگوهای طراحی با توجه به کاربردها و اهدافی که به آن منظور ارائه شده اند، به سه دسته عمومی سازنده (Creational)، ساختاری (Structural) و رفتاری (Behavioral) تقسیم‌بندی شده‌اند. الگوهای سازنده به فرآیند ایجاد اشیا مربوط می‌شوند. الگوهای ساختاری به ترکیب کلاس‌ها یا اشیا می‌پردازند. الگوهای رفتاری شیوه‌هایی را که در آن‌ها کلاس‌ها یا اشیا تعامل می‌کنند را مشخص کرده و وظایف را توزیع می‌کنند. 2- الگوهای طراحی با توجه به حوزه (Scope) مورد استفاده نیز به دو دسته الگوهای کلاس و شی تقسیم می‌شوند. الگوهای کلاس به روابط میان کلاس‌ها و کلاس‌های فرعی آن‌ها می‌پردازد. این روابط به گونه‌ای از طریق وراثت مستقر می‌گردند که در زمان کامپایل ایستا باشند. الگوهای شی به روابط اشیا می‌پردازند که می‌تواند در حین اجرا تغییر کنند و پویاتر هستند. تقریبا کلیه‌ی الگوها تا حدی از وراثت استفاده می‌کنند. توجه داشته باشید اغلب الگوها در حوزه شی قرار می‌گیرند. الگوهای کلاس سازنده بخشی از سازنده اشیا را به کلاس‌های فرعی واگذار می‌کنند، در حالی‌که الگوها‌ی شی سازنده آن را با شی دیگری تعویض می‌کنند. الگوهای کلاس ساختاری از وراثت جهت ساختن کلاس‌ها استفاده می‌کنند، در حالی‌که الگوهای شی ساختاری به شرح راه‌هایی جهت نصب اشیا می‌پردازد. الگوهای کلاس رفتاری از وراثت جهت توصیف الگوریتم‌ها و جریان کنترل استفاده می‌کنند، در حالی‌که الگوهای شی رفتاری شرح می‌دهند که چگونه یک گروه از اشیا جهت انجام وظیفه‌ای که هیچ شی منفردی قابل به انجام آن نیست مشارکت می‌کنند.\n","date":"May 29, 2019","img":"","permalink":"/posts/design-patterns/","series":[],"tags":["gof","design patterns"],"title":"الگوهای طراحی (Design Patterns) چیست؟"},{"categories":["General"],"content":"همزه (ء) در میان حروف سی‌ودو گانه‌ی الفبای فارسی شکلی از ملحقات حرف «الف» (صامت) است. شکل جدای آن (ء) و در حالت‌های گوناگون با ترکیب دیگر اشکال به صورت (آ - أ - ئ - ؤ) نوشته می‌شود. همزه از نظر آواشناسی در میان واج‌های زبان فارسی به‌طور مستقل یک صامت است که به اشکال (ء - ا) نوشته می‌شود.\nکلمات همزه‌دار از عربی وارد زبان فارسی شده‌اند. اما املای کلمات همزه دار در زبان فارسی با زبان عربی متفاوت است. کلماتی که ریشه‌ی فارسی دارند، گاهی با همزه نوشته می‌شوند که نادرست است. مانند: پائیز، پائین، بوئیدن، روئیدن، می‌آئید که شیوه صحیح نگارش آن‌ها، پاییز، پایین، بوییدن و روییدن و می‌آیید است. انواع همزه عبارتند از:\nالف همزه (منشأ) الف همزه مکسوره (إفعال) واو همزه (سؤال) ی همزه (هیئت) همزه تنها که معمولا پس از الف می‌آید (امحاء) همزه با توجه به اینکه کجای کلمه باشد و حرکه ی خود یا حرف پیش و پس از خود، املای متفاوتی خواهد داشت:\nهمزه کسره‌دار و همزه قبل از ی در وسط کلمه همزه‌ای که کسره دارد، روی پایه ی نوشته می‌شود؛ مانند: مسائل، مصائب، ارائه، قائل، تخطئه. همزه کسره‌دار در برخی موارد نیز کلا تبدیل به ی می‌شود؛ مانند: دایره، فایده، جایزه، معایب، نایب، زایل. این که آن را به صورت ئ یا ی بنویسید، بسته به این دارد که کدام رایج‌تر است و گاهی نیز سلیقه‌ای می‌شود. بهتر است به حالت گویشی آن رجوع کنید و ببینید کدام به گوش شما آشناتر است. اما مهم این است که اگر حالتی را برای یک کلمه انتخاب کردید، آن را در تمامی نوشتار خود مراعات کنید. همین قاعده در مورد همزه‌ای که قبل از ی قرار دارد نیز صادق است. ممکن است به صورت ئ یا به صورت ی نوشته شوند. مانند: لئیم، رئیس، جبرئیل و اسرائیل که رییس، جبرییل و اسراییل نیز رایج هستند.\nهمزه فتحه‌دار در وسط کلمه؛ مسأله یا مسئله برای این که بدانیم املای درست همزه مفتوح در وسط کلمه چیست، به حرکه حرف قبل از آن رجوع می‌‌کنیم: همزه مفتوحی که قبل از آن الف باشد، همه آن را به صورت ئ می‌نویسند؛ مانند: قرائت، دنائت، برائت. همزه مفتوحی که قبل از آن، حرفی با ضمه آمده باشد، بر پایه واو نوشته می‌شود؛ مانند: مؤدّب، مؤخّر، مؤلّف. همزه مفتوحی که قبل از آن حرفی با فتحه آمده باشد، بر پایه الف نوشته می‌شود؛ مانند: متأخّر، مستأصل. اما اگر حرف قبل از همزه مفتوح ساکن باشد چه؟ این مورد محل اختلاف است و اتفاق نظر در مورد آن وجود ندارد. بعضی همزه میانیِ مفتوحِ ما قبل ساکن را به صورت مسأله، نشأت و هیأت صحیح می‌دانند. اما برخی دیگر، از جلمه فرهنگستان زبان فارسی، مسئله، نشئت و هیئت را صحیح‌تر دانسته اند. نکته مهم، سازگاری در متن است. اگر یک روش نوشتاری را انتخاب کردید، همه جای متنتان از همان استفاده کنید و جایی از متن مسأله و جایی دیگر مسئله ننویسید.\nهمزه پس از حرف ساکن یا فتحه‌دار و قبل از مصوت آ اما اگر همزه ساکن یا فتحه‌دار باشد و پس از آن مصوت آ بیاید، آن را با علامت مد «آ» درج می‌کنیم؛ مانند: قرآن، مِرْآت، مَآخِذ.\nهمزه ضمه‌دار و همزه قبل از واو در وسط کلمه؛ مسؤول یا مسئول در مورد همزه مضموم و همزه قبل از واو هم اختلاف وجود دارد. برخی بر طبق قاعده‌ای کلی در عربی، مسؤول و رؤوس را صحیح می‌دانند. اما برخی معتقدند که املای رایج و درست این کلمات در فارسی، مسئول و رئوس است. پس می‌توان هر دو مورد را صحیح دانست.\nهمزه ساکن در وسط کلمه زمانی که همزه در وسط کلمه ساکن است، برای این که بدانیم آن را روی چه پایه‌ای بنویسیم، به حرکه حرف قبل از آن نگاه می‌کنیم، و برای فتحه الف، برای کسره ی و برای ضمه واو را پایه همزه قرار می‌دهیم؛ مانند: همزه ساکن ما قبل مفتوح: رأفت، مأمور؛ همزه ساکن ما قبل مکسور: ائتلاف؛ همزه ساکن ما قبل مضموم: سؤال، رؤیا.\nهمزه پایانی بعد از الف ممدوه؛ املاء یا املا همزه بعد از الف ممدوده، در زبان فارسی حذف می‌شود. پس کلماتی مانند املاء، انشاء، اعضاء، استثناء به صورت املا، انشا، اعضا و استثنا نوشته می‌شوند. نکته: هر گاه کلماتی که در بالا گفتیم، در نقش موصوف یا مضاف قرار گیرند، به جای کسره اضافه، به انتهای آن‌ها ی اضافه می‌شود و باز هم همزه حذف خواهد شد؛ مانند: املای درست، انشای بهروز، اعضای گروه، استثنای مهم. عبارت ان شاء الله یک عبارت عربی است به معنی «اگر خدا بخواهد» که عینا در فارسی استفاده می‌شود و همزه آن حذف نمی‌شود. بنابراین بهتر است آن را به صورت سه کلمه مجزا آورده و از نوشتن آن به صورت انشاالله یا انشاءالله خودداری کنیم چرا که معنی آن تغییر می‌کنید و معنی «انشای خدا»‌ خواهد داد!\nهمزه پایانی پس از ساکن یا بعد از مصورت‌های مصوّت‌های «ی» و «او» همزه پایانی که قبل از آن یک حرف ساکن یا یکی از مصوّت‌های «ی» و «او» باشد، بدون پایه نوشته می‌شود؛ مانند: شیء، سوء، جزء.\nهمزه پایانی پس از حرف مفتوح همزه پایانی که قبل از آن حرفی با فتحه وجود داشته باشد، بر پایه الف نوشته می‌شود؛ مانند: خلأ، ملجأ، مبدأ.\nهمزه پایانی پس از حرف مضموم همزه پایانی که قبل از آن حرفی با ضمه آمده باشد، بر پایه واو نوشته می‌شود؛ مانند: تلألؤ، لؤلؤ.\nهمزه در کلمات وارد شده از زبان‌های بیگانه در مورد کلمات غیرعربی و غیر فارسی، همیشه همزه میانی را بر پایه ی درج می‌کنیم؛ مانند: ژوئن، پنگوئن، زئوس، نئون، ژئوفیزیک.\n","date":"May 1, 2019","img":"","permalink":"/posts/hamzeh/","series":[],"tags":["Persian","Farsi"],"title":"املای درست همزه در فارسی"},{"categories":null,"content":"من آرمان حسن پور هستم. از سال 1390 شروع به برنامه‌نویسی کردم. با زبان‌های برنامه‌نویسی زیادی کار کردم ولی بیشتر از زبان برنامه‌نویسی، توانایی حل مسئله برای من ارزشمند است. بیشتر فعالیت‌های من در حوزه‌های مالی و بانکی بوده است و همچنین در مدیریت بانک‌های اطلاعاتی دارای مهارت هستم. علاقه‌مند به یادگیری و کسب مهارت در حوزه‌های جدید فناوری اطلاعات نیز هستم و همواره تلاش می‌کنم که دانش خود را در این حوزه به روز نمایم.\n","date":"Feb 28, 2019","img":"","permalink":"/about/","series":null,"tags":null,"title":"در مورد من"},{"categories":["Oracle","SQL"],"content":"در برخی از سناریوها نیاز به نمایش خروجی چند مقدار به صورت یک مقدار با یک جداکننده مانند کاما داریم. در Oracle می‌توان از تابع LISTAGG برای تبدیل نتایج پرس‌و‌جو به صورت یک مقدار جداشده با کاما استفاده نمود.\nبه طور مثال پرس‌و‌جوی زیر نام قاره‌ها را از جدول regions باز می‌گرداند.\n1SELECT region_name 2FROM regions; نتیجه:\n1REGION_NAME 2------------------------ 3Americas 4Asia 5Middle East and Africa این پرس‌و‌جو چهار سطر مختلف به عنوان نتیجه را باز می‌گرداند. اما اگر بخواهیم این چهار سطر را به صورت یک مقدار جدا شده با کاما نمایش دهیم می‌توانیم آن را به صورت زیر انجام دهیم:\n1SELECT LISTAGG(region_name, \u0026#39;, \u0026#39;) 2FROM regions; نتیجه:\n1LISTAGG(LAST_NAME,\u0026#39;,\u0026#39;) 2----------------------------------------------- 3Europe, Americas, Asia, Middle East and Africa تابع LISTAGG دو مقدار را به عنوان ورودی دریافت می‌نماید. مقدار اول نام ستون و مقدار دوم جدا کننده مورد نظر می‌باشد که در این مثال کاراکتر کاما است. مقدار دوم اختیاری است و اگر داده نشود بدون جدا کننده مقادیر بهم چسبانده می‌شوند.\nامکان استفاده از عبارت DISTINCT در تابع LISTAGG به منظور حذف مقادیر تکراری نیز وجود دارد.\n1SELECT LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2FROM countries نتیجه:\n1LISTAGG(DISTINCT region_id, \u0026#39;,\u0026#39;) 2-------------------------------------------- 31,2,3,4 به منظور مرتب سازی نتایج در تابع LISTAGG می‌توان از عبارت WITHIN GROUP (ORDER BY\u0026hellip;) استفاده نمود.\n1SELECT LISTAGG(region_name, \u0026#39;,\u0026#39;) WITHIN GROUP (ORDER BY region_name ASC) 2FROM regions; نتیجه:\n1LISTAGG(region_name, \u0026#39;,\u0026#39;) 2-------------------------------------------- 3Americas,Asia,Europe,Middle East and Africa از تابع LISTAGG می توان در یک پرس‌و‌جو گروه‌بندی شده نیز استفاده نمود.\n1SELECT 2 region_id, 3 LISTAGG(country_id, \u0026#39;, \u0026#39;) WITHIN GROUP (ORDER BY country_id ASC) AS \u0026#34;Countries\u0026#34; 4FROM countries 5GROUP BY region_id 6ORDER BY region_id; نتیجه:\n1REGION_ID\tCountries 2------------------------------------------------ 31\tBE, CH, DE, DK, FR, IT, NL, UK 42\tAR, BR, CA, MX, US 53\tAU, CN, HK, IN, JP, SG 64\tEG, IL, KW, NG, ZM, ZW ","date":"Feb 5, 2019","img":"","permalink":"/posts/oracle-lisagg/","series":[],"tags":["Oracle","LISTAGG","Comma Separated List","SQL"],"title":"نمایش نتایج پرس‌و‌جوها به صورت یک مقدار جداشده با کاما در Oracle"},{"categories":["OOP"],"content":"اعضای داده‌ای خصوصی (private) یک کلاس تنها توسط توابع عضو آن کلاس قابل دسترسی هستند. بنابراین هر کلاس یا تابعی که از توابع عضو یک شی استفاده می‌کند و آن را از خارج از شی فراخوانی می‌کند، تنها می‌تواند توابع عمومی (public) عضو کلاس را به منظور درخواست سرویس‌های کلاس از هر شی خاص فراخوانی نماید.\nدر برنامه‌نویسی شی‌گرا کلاس‌ها از توابع عضو عمومی برای انجام عمل set (یعنی نسب دادن مقدار به) و get (یعنی به دست آوردن مقدار از) برای دسترسی به اعضای داده‌ای خصوصی کلاس استفاده می‌کنند. این نام‎گذاری یک قرارداد متداول است و حتما لازم نیست نام این توابع عضو با set یا get آغاز گردد. توابع set گاهی اوقات تغییردهنده (mutator) نامیده می‌شوند (زیرا آن‌ها مقادیر را تغییر می‌دهند). همچنین توابع get نیز گاهی اوقات دست‌یابنده (accessor) نامیده می‌شوند (زیرا آن‌ها مقادیر را بازیابی می‌نمایند). از طریق توابع set و get می‌توان دسترسی استفاده‌کنندگان از داده‌های خصوصی یک شی را کنترل نمود. این ویژگی اهمیت زیادی در مهندسی نرم‌افزار دارد زیرا اعلان اعضای داده‌ای با سطح دسترسی خصوصی منجر به رعایت اصل پنهان‌سازی داده (encapsulation) می‌شود. اگر توابع set و get را به‌صورت عمومی در اختیار سایرین قرار دهیم استفاده‌کنندگان یک کلاس تنها به صورت غیرمستقیم می‌توانند به داده‌های خصوصی کلاس دستیابی داشته باشند. استفاده‌کنندگان از کلاس فقط می‌توانند داده‌های یک شی را تغییر داده یا آن را بازیابی کند و از نحوه‌ی انجام این کار اطلاعی نداشته باشند. در برخی موارد، ممکن است نحوه‌ی استفاده‌ی داخلی یک کلاس از یک عضو داده‌ای و کاری که بر روی آن انجام می‌دهد، با طرز ارائه‌ی آن به استفاده کننده از آن داده و نحوه‌ی نمایش آن، بسیار متفاوت باشد. توابع set و get به استفاده‌کنندگان کلاس امکان تعامل با شی را می‌دهند، اما داده‌های خصوصی به شکل ایمن در خود شی، به‌صورت پنهان (encapsulated) باقی می‌مانند. به عنوان مثال کلاس Customer یک عضو داده‌ای به نام name داشته و از آن‌ها برای نگهداری نام مشتری هر شی خاصی از کلاس Customer استفاده می‌کند. کلاس مزبور حاوی توابع عضو setName و getName می‌باشد. تابع عضو setName نام مشتری را در یک عضو داده از کلاس Customer ذخیره می‌نماید – تابع عضو getName نام مشتری را در یک عضو داده‌ای از کلاس Customer بازیابی می‌کند.\n1public class Customer { 2 private String name; 3 4 // Getter 5 public String getName() { 6 return name; 7 } 8 9 // Setter 10 public void setName(String newName) { 11 this.name = newName; 12 } 13} شاید فکر کنید که حتی اگر اعضای داده‌ای به صورت خصوصی تعریف شوند، استفاده‌کنندگان همچنان می‌توانند هر زمان که بخواهند به کمک توابع set و get آن‌ها را بخوانند و دستکاری کنند، پس فایده‌ی این مخفی‌کاری چیست؟! جواب این است که توابع set را می‌توان طوری نوشت که داده‌های ورودی به اعضای داده‌ای را کنترل و فیلتر کنند و به هر داده‌ای اجازه‌ی نوشته‌شدن در اعضای داده‌ای را ندهند. همچنین می‌توان به کمک تابع get قالب نمایش داده‌ها را کنترل نمود. برای مثال می‌توانید به کمک تابع set از نوشته شدن مقادیر منفی در عضو داده‌ای \u0026ldquo;نمره\u0026rdquo; جلوگیری نمایید.\n1public class Grade { 2 private int theGrade; 3 4 // Getter 5 public int getGrade() { 6 return theGrade; 7 } 8 9 // Setter 10 public void setAge(int newGrade) { 11\tif(newGrade \u0026gt; 0) 12 this.theGrade = newGrade; 13 } 14} برای مثال دیگر می‌توانید عضو داده‌ای \u0026ldquo;نمره\u0026rdquo; را به صورت کیفی با یک رشته (\u0026ldquo;عالی\u0026rdquo;، \u0026ldquo;خوب\u0026rdquo;، \u0026ldquo;متوسط\u0026rdquo;، \u0026ldquo;قابل قبول\u0026rdquo; و \u0026ldquo;مردود\u0026rdquo;) بازیابی نمایید.\n1public class Grade { 2 private int theGrade; 3 4 // Getter 5 public String getGrade() { 6 if(theGrade \u0026gt;= 80) 7\treturn \u0026#34;Excellent\u0026#34;; 8\telse if(theGrade \u0026gt;= 60 and theGrade \u0026lt; 80) 9\treturn \u0026#34;Good\u0026#34;; 10\telse if(theGrade \u0026gt;= 50 and theGrade \u0026lt; 60) 11\treturn \u0026#34;Average\u0026#34;;\t12\telse if(theGrade \u0026gt;= 40 and theGrade \u0026lt; 50) 13\treturn \u0026#34;Acceptable\u0026#34;; 14\telse if(theGrade \u0026lt; 40) 15\treturn \u0026#34;Fail\u0026#34;; 16\telse\t17\treturn \u0026#34;Invalid grade\u0026#34;; 18 } 19 20 // Setter 21 public void setAge(int newGrade) { 22\tif(newGrade \u0026gt; 0) 23 this.theGrade = newGrade; 24 } 25} هرچند که توابع عضو درون کلاس می‌تواند داده‌های خصوصی را مستقیما مورد دستیابی قرار دهند، اما بهتر است این توابع نیز برای اداره‌ی داده‌های خصوصی کلاس از توابع set و get استفاده کنند. به عنوان مثال تابع displayMessage یک پیغام مبنی بر معرفی مشتری که نام و سن مشتری در آن است را در خروجی نمایش می‌دهد.\n1public class Customer { 2 private String name; 3 private int age; 4 5 // Getter 6 public String getName() { 7 return name; 8 } 9 10 // Setter 11 public void setName(String newName) { 12 this.name = newName; 13 } 14 15 // Getter 16 public int getAge() { 17 return age; 18 } 19 20 // Setter 21 public void setAge(int newAge) { 22 this.age = newAge; 23 } 24 25 public String displayMessage() { 26 return \u0026#34;My name is \u0026#34; + getName() + \u0026#34;. I am \u0026#34; + getAge() + \u0026#34;years old.\u0026#34;; 27 } 28} کنترل مقادیر ورودی به اعضای داده‌ای و قالب‌بندی نمایش آن‌ها می‌تواند تاثیر به‌سزایی در کاهش خطاها و خوانایی برنامه داشته باشد و پایداری و امنیت برنامه را بالا ببرد.\n","date":"Jan 12, 2018","img":"","permalink":"/posts/oop-get-set/","series":[],"tags":["OOP","OOD","Object Oriented","Object"],"title":"مهندسی نرم‌افزار با توابع Get و Set"},{"categories":["General"],"content":"همه‌ی ما می‌دانیم که کامپیوترها تنها با اعداد و ارقام سر و کار دارند و تمام اطلاعات نوشتاری، صوتی و تصویری را به صورت اعداد و ارقام پردازش و ذخیره می‌کنند. حروف، اعداد و علایمی که در اپلیکیشن‌ها مورد استفاده قرار می‌گیرند، به آن شکلی که شما آن‌ها را می‌بینید در کامپیوتر مدیریت نمی‌شوند. برای قابل فهم کردن اطلاعات برای کامپیوتر لازم است برای هر حروف از الفبا، یک عددی اختصاص دهیم. حروف و کاراکترها به مجموعه‌ای از 0 و 1 تبدیل می‌شود تا مدیریت آن‌ها برای کامپیوتر ساده‌تر باشد. اختصاص این کدها به اطلاعات توسط سیستم‌های کدگذاری انجام خواهد شد. برای این منظور صدها نوع سیستم کدگذاری برای قابل فهم کردن زبان‌های مختلف برای کامپیوترها به وجود آمد.\nبرای زبان فارسی هم تعداد زیادی سیستم‌های کدگذاری به وجود آمد. هر شرکت نرم‌افزاری یک سیستم کدگذاری مخصوص به خودش را داشت. البته وجود تعداد زیاد سیستم‌های کدگذاری تنها مختص به زبان فارسی نبوده و بیشتر زبان‌های دیگر هم با این مشکل روبرو بودند. کد اسکی یا ASCII چیست؟ انجمن استانداردهای آمریکا در سال 1960 روش کدگذاری 7 بیتی ASCII را معرفی کرد. ASCII مخفف عبارت American Standard Code for Information Interchange است که در آن زمان شامل 128 کاراکتر یا 7 بیت تعریف شد. ASCII از کد تلگراف تهیه شده‌است. اولین استفاده تجاری آن به عنوان یک کد ماشین تحریر الکترومکانیکی هفت بیتی بود که توسط خدمات داده بل Bell عرضه شد. کار بر روی استاندارد ASCII از ۶ اکتبر ۱۹۶۰ با اولین جلسه انجمن استانداردهای آمریکایی (اکنون موسسه استاندارد ملی آمریکا یا ANSI) آغاز شد. ASCII بر اساس الفبای انگلیسی، 128 کاراکتر مشخص شده را به صورت عدد صحیح هفت بیتی، همان‌طور که در جدول ASCII نشان داده شده‌است، کدگذاری می‌کند. نود و پنج از کاراکتر های کدگذاری شده قابل چاپ هستند: این‌ها شامل رقم‌های ۰ تا ۹، حروف کوچک a تا z، حروف بزرگ A تا Z و نمادهای نقطه‌گذاری هستند. علاوه بر این، ASCII شامل ۳۳ کد کنترل غیر چاپی بود که از ماشین‌های تحریر سرچشمه می‌گرفتند. بسیاری از این موارد اکنون منسوخ شده‌اند، اگرچه تعداد معدودی از آنها هنوز هم به‌طور معمول مورد استفاده قرار می‌گیرند. استاندارد ارائه‌شده در آن زمان بیشتر برای زبان‌های لاتین کاربرد داشت. پس از آن در دهه‌ی 1980 تصمیم گرفتند که این استاندارد به جای استفاده از 7 بیت، از یک بایت کامل استفاده کند. یک بایت کامل شامل 8 بیت و 256 کاراکتر است. از این رو زبان‌های دیگر نیز می‌توانستند از این استاندارد استفاده کنند. ASCII به روشنی مشخص نکرده که مقادیر بین 128 تا 255 به چه چیزی اختصاص دارد. در بین زبان دیگر استاندارد واحدی وجود نداشت و هر زبانی الفبای خود را با کد مختص به الفبای خود نشان می‌داد. پس در این زمان به استاندارد واحدی که با تمامی زبان‌ها سازگار باشد و برای هر کاراکتر کد مختص به خود را داشته باشد، نیاز بود. برای حل این مشکل سازندگان کامپیوتر‌ها سعی کردند از صفحه‌های کد (Code Pages) استفاده کنند که از مقادیر تعریف شده 128 تا 255 در ASCII استفاده کرده و آن را به کاراکترهای مختلف مورد نیاز برای نمایش زبان‌های دیگر نگاشت می‌کند. متأسفانه این 128 کاراکتر اضافی برای کل دنیا کافی نبودند؛ صفحه‌های کد بر اساس زبان کشورها متفاوت هستند و برای مثال صفحه کد روسی، صفحه کد فارسی و غیره پدید آمدند. در این حالت، کاراکتر شماره 200 روی یک کامپیوتر همان کاراکتر شماره 200 روی کامپیوتر دیگر بود. اما باز هم این روش کارساز نبود. تا زمانی که افراد از صفحه‌های کد یکسانی استفاده کنند، همه چیز خوب پیش می‌رود اما اگر کد صفحه‌ها برای افراد یکسان نباشد، همه چیز به هم می‌ریزد. وجود یک استاندارد واحد برای کدگذاری در بین زبان‌های مختلف کلید حل این مشکل وجود یک استاندارد واحد بود. بر این اساس مشخص می‌شود که هر کدام از این اعداد چه کاراکترهایی را نمایش می‌دهند. در ابتدا دو استاندارد برای ایجاد مجموعه کاراکترهای واحد صورت گرفت. اولی ISO-10646 و دیگری Unicode بود. اما وجود دو استاندارد باز هم مشکل را به صورت کامل حل نکرد. بر این اساس ISO و Unicode تصمیم گرفتند در سال 1991 به یکدیگر بپیوندند. از این رو با معرفی یونی‌کُد (unicode) این مشکل حل شد. حال سوال این است که یونی‌کُد چیست؟ یونی‌کُد یا Unicode چیست؟ یونی‌کُد یا همان Universal Character Set Transformation Format یک استاندارد بین‌المللی است که برای کدبندی کاراکترها و نمایش و پردازش متون چندزبانه مورد استفاده قرار می‌گیرد. این استاندارد به صورت کتابی به نام ‘The Unicode Standard’ نیز منتشر شده‌است. یونی‌کُد در واقع مجموعه‌ای از کاراکترها (charset) با اعداد منحصر به فرد است که به آنها در اصطلاح نقطه کد (Point Code) گفته می‌شود. هر Point Code کاراکتر واحدی را نمایش می‌دهد. برای نمونه A به نقطه کد U+0041 نگاشت شد. این نقطه کد به صورت هگزادسیمال بیان شده و همان 65 در سیستم ده‌دهی است. گروه یونی‌کُد کار دشوار نگاشت هر کاراکتر در همه‌ی زبان‌ها به یک نقطه کد را به انجام رسانید. زمانی که همه‌ی این نقطه کدها تخصیص یافتند، استاندارد یونی‌کُد همچنان فضای کافی برای 1 میلیون نقطه کد دیگر نیز داشت که برای همه تمدن‌های شناخته شده و حتی کشف نشده آینده نیز فضای کافی ارائه می‌کند. شما می‌توانید نقطه کدها را در ویندوز با مراجعه به مسیر Start Menu \u0026gt; Run \u0026gt; Charmap یا به صورت آنلاین در وب‌سایت Unicode.org ملاحظه کنید. یونی‌کُد مستقل از سیستم عامل و یا برنامه و زبان خاصی، به هر یک از حروف یک کد یکتا اختصاص می‌دهد. یونی‌کُد می‌تواند تمام حروف زبان‌های مختلف دنیا را در خود جای دهد. یونی‌کُد می‌تواند برای وبسایت‌ها و برنامه‌ها بسیار کاربردی باشد، از این رو که می‌توان گفت مهم نیست کاربران از چه وبسایت و یا چه مرورگری استفاده می‌کنند؛ تنها کافی است از یونی‌کُد پشتیبانی کند. امروزه اکثر شرکت‌های بزرگ دنیای کامپیوتر از این استاندارد استفاده می‌کنند و همچنین می‌توان گفت که تقریبا تمام برنامه‌های کاربردی جدید با این استاندارد کدگذاری شده‌اند. گسترش استاندارد یونی‌کُد موجب شده تا تمامی فارسی زبان‌ها هم بتوانند در دنیای اینترنت مطالب خود را عرضه کنند. یونی‌کُد موجب شده تا فرایند ایجاد وبسایت‌ها و برنامه‌های فارسی بسیار آسان‌تر و کم هزینه‌تر باشد. در زمان طراحی یونی‌کُد جهت ایجاد تطبیق‌پذیری (compatibility) با سیستم ASCII، همه نقطه کدها از U+0000 تا U+007F یعنی از 0 تا 127 همان کدهای ASCII بودند. افراد باریک‌بین احتمالاً از این موضوع راضی نبوده‌اند، چون مجموعه کامل کاراکترهای لاتین در جای دیگری تعریف شده بود و اینکه یک حرف 1 نقطه کد داشت. ضمناً این وضعیت باعث می‌شد که کاراکترهای لاتین در اولویت قرار بگیرند در حالی که کاراکترهای چینی، عربی و زبان‌های غیراستاندارد در نقطه کدهای بعدی قرار بگیرند که نیازمند 2 بایت برای ذخیره‌سازی بود. با این وجود، این طراحی ناگزیر بود، چون ASCII یک استاندارد بود و بسیاری از ابزارها و پروتکل‌های ارتباطی تنها کاراکترهای ASCII را می‌پذیرند و اگر یونی‌کُد قرار بود از سوی کل دنیا پذیرفته شود، بی‌شک باید با آن سازگاری می‌داشت. اما یک سؤال همچنان بی‌پاسخ ماند: چگونه می‌توانیم یک نقطه کد را به عنوان داده ذخیره کنیم؟ انکودینگ Encoding راه نجات است.\nانکودینگ یا همان Encoding چیست؟ تبدیل داده‌ها به صورتی که سیستم توانایی خواندن و استفاده از آن را داشته باشد Encoding گویند. کدهای یکتا به روش‌های متفاوتی در کامپیوتر ذخیره می‌شوند؛ این روش‌ها را کدگذاری یا Encoding می‌گویند. می‌توان گفت که کدگذاری فرآیند تبدیل داده‌ها به فرمت‌های مورد نیاز است. این کدگذاری شامل تدوین برنامه‌ها، اجرای برنامه انتقال و ذخیره‌سازی داده‌ها و همچنین پردازش داده‌های برنامه است. روش‌های کدگذاری یوینکد یونی‌کُد به سه روش مختلف کدگذاری می‌شود؛ UTF-8، UTF-16 و UTF-32. حال سوال این است که UTF چیست؟ تفاوت این روش‌های کدگذاری در چیست؟ UTF مخفف عبارت Unicode Transformation Format است که به معنی \u0026ldquo;فرمت تبدیل یونی‌کُد\u0026rdquo; است. UTF روش کدگذاری است که زیر مجموعه‌ای از استاندارد یونی‌کُد به شمار می‌رود. در ادامه بیشتر با روش‌های کدگذاری یونی‌کُد و تفاوت‌های آنها آشنا خواهید شد. مقایسه روش‌های کدگذاری UTF-8، UTF-16 و UTF-32 از تفاوت‌های این سه روش کدگذاری می‌توان به نحوه‌ی ارائه‌ی‌ حروف، اعداد و علایم مختلف اشاره کرد. روش‌های کدگذاری UTF-8 و UTF-16 هر دو دارای عرض متغیر هستند و می‌توانند از حداکثر 4 بایت برای کدگذاری استفاده کنند. اما در حالت حداقل،UTF-8 فقط از یک بایت (معادل 8 بیت) استفاده می‌کند ولی UTF-16 از 2 بایت (معادل 16 بیت) استفاده می‌کند. این تفاوت تاثیر زیادی در اندازه فایل‌های کدگذاری شده دارد. به زبانی دیگر می‌توان گفت که یک فایل کدگذاری شده با UTF-16 تقریبا دو برابر بزرگ‌تر از فایل‌های کدگذاری شده با UTF-8 است. UTF-32 برخلاف دو روش قبلی، طول ثابتی دارد و بیشترین فضا را اشغال می‌کند. از سوی دیگر می‌توان گفت که UTF-8 با ASCII سازگار است اما روش کدگذاری UTF-16 با ASCII ناسازگار است. روش کدگذاری UTF-8 مبتنی بر بایت byte-oriented است و با شبکه‌ها و فایل‌های مبتنی بر بایت مشکلی ندارد؛ اما UTF-16 مبتنی بر بایت نیست و برای کار با شبکه‌های مبتنی بر بایت نیاز به سفارشی‌سازی دارد. همچنین می‌توان گفت که UTF-8 در بازیابی از خطاها در مقایسه با UTF-16 بهتر عمل می‌کند. در این مواقع UTF-8 می‌تواند بایت غیر خراب بعدی را رمزگشایی کند. UTF-16 هم در صورت خراب شدن بایت‌ها همین کار را می‌کند اما زمانی که برخی از بایت‌ها گم شوند، مشکل رخ می‌دهند. بایت گمشده ترکیب‌های بایت را با هم مخلوط می‌کند و نتیجه نهایی از بین می‌رود.\nUTF-8 UTF-8 مخفف عبارت Unicode Transformation Format 8-bit به معنای فرمت تبدیل یونی‌کُد 8 بیتی است. UTF-8 یکی از روش‌های کدگذاری یک بایتی (معادل 8 بیت) با عرض متغیر است که برای ارتباط الکترونیکی استفاده می‌شود. در کنفرانس USENIX در سال 1993، UTF-8 به طور رسمی معرفی شد. UTF-8 پرکاربردترین و رایج‌ترین روش برای نمایش متن یونی‌کُد در صفحات وب است. UTF-8 کدگذاری غالب برای شبکه جهانی وب (و فناوری‌های اینترنت) است که تا سال 2022، 98٪ از کل صفحات وب و تا 100.0٪ برای برخی از زبان‌ها را شامل می‌شود. در این روش کدگذاری هر کاراکتر با یک تا چهار بایت نمایش داده می‌شود. UTF-8 با ASCII سازگار است و می‌تواند هر کاراکتر استاندارد یونی‌کُد را نشان دهد. این استاندارد رمزگذاری قادر است همه‌ی کد کاراکترها معتبر در یونی‌کُد را با استفاده از یک تا چهار واحد کد یک بایتی (8 بیتی) رمزگذاری کند. UTF-8 یکی از روش‌های رمزگذاری است که توسط سازمان بین‌المللی استاندارد (ISO) در ISO-10646 تعریف شده است. این کد می‌تواند حداکثر 2,097,152 نقطه کد (2^21) را نشان دهد که بیش از اندازه کافی برای پوشش 1,112,064 کاراکتر یا نقطه کد فعلی است. همان طور که گفته شد، UTF-8 یک استاندارد رمزگذاری \u0026ldquo;با عرض متغیر\u0026rdquo; است. حال سوال این است که طول متغییر به چه معنا است؟ این بدان معنی است که هر نقطه کد را با تعداد متفاوتی از بایت‌ها، بین یک تا چهار بایت رمزگذاری می‌کند. این کار برای صرفه‌جویی در فضا بسیار مناسب است. نقاط کد رایج مورد استفاده معمولا با بایت‌های کمتری نسبت به نقاط کد که به ندرت مورد استفاده قرار می‌گیرد، کدگذاری می‌شود. UTF-8 الگوریتمی است که اعداد مربوط به پوینت‌کدها را به باینری تبدیل می‌کند. از این رو می‌توان آن‌ها را بر روی دیسک ذخیره کرد و یا از طریق شبکه انتقال داد.\nشاخص‌گذاری در کدگذاری یونی‌کُد ذخیره‌سازی داده‌ها در چندین بایت باعث بروز مشکلی به نام ترتیب بایت byte order می‌شود. برخی کامپیوترها بایت کوچک‌تر را ابتدا ذخیره می‌کنند و برخی دیگر بایت بزرگ را اول ذخیره‌سازی می‌کنند. از آنجا که در کدگذاری های یونی‌کُد نیز از چندین بایت برای ذخیره‌سازی استفاده می‌شود این مشکل در کدگذاری‌های یونی‌کُد نیز وجود دارد. برای حل این مشکل می‌توانیم کارهای زیر را انجام دهیم:\nگزینه 1: انتخاب یک قرارداد ما یک قرارداد می‌گذاریم که همه داده‌های متنی باید به صورت big-endian یا little-endian باشند. البته این قرارداد پاسخگو نیست، زیرا کامپیوترها در جریان تصمیم‌گیری ما نیستند و هر بار که فایلی را باز می‌کنند نمی‌توانند تشخیص دهند که از چه ترتیب بایتی باید برای تبدیل آن استفاده کنند.\nگزینه 2: همه افراد بر سر یک شاخص ترتیب بایت (BOM) Byte Order Mark توافق می‌کنند بدین ترتیب یک هدر Header به ابتدای هر فایل اضافه می‌شود. انکودینگ های یونی‌کُد می‌توانند نقطه کد U+FEFF را به عنوان هدر فایل بنویسند. اگر یک رشته‌ی کدگذاری شده یونی‌کُد را باز کنید و با عبارت FEFF مواجه شوید، داده‌هایی که در ترتیب صحیح بایت قرار دارند می‌توانند به صورت مستقیم استفاده شوند. اگر با FFFE مواجه شود به این معنی است که داده‌ها از کامپیوتری با نوع متفاوت می‌آیند و باید به معماری مورد نظر شما تبدیل شوند. بدین ترتیب باید همه بایت‌های موجود در فایل معکوس شوند. اما متأسفانه همه مسائل به این سادگی نیستند. BOM در واقع یک کاراکتر معتبر یونی‌کُد است. اگر فردی فایلی بدون یک هدر ارسال کند و آن کاراکتر در واقع بخشی از فایل باشد چه رخ می‌دهد؟ این وضعیت همچنان یک مشکل حل نشده در یونی‌کُد محسوب می‌شود. پیشنهاد شده است که از کاراکتر U+FEFF و U+FFFE به جز در هدر فایل اجتناب و از کاراکترهای جایگزین به جای آن استفاده شود. این وضعیت مشاهده شماره 2 طراحی یونی‌کُد را مشخص می‌سازد: داده‌های چند بایتی مشکل ترتیب بایت را دارند! در استاندارد ASCII هرگز در مورد ترتیب بایت دغدغه‌ای وجود ندارد. در این سیستم هر کاراکتر یک بایت منفرد است و نمی‌تواند به صورت نادرستی تفسیر شود. اما در عمل وقتی بایت‌های 0xFEFF یا 0xFFEE را در ابتدای فایل می‌بینید این احتمال وجود دارد که یک BOM در یک فایل متنی یونی‌کُد است. این کاراکترها به احتمال زیاد یک نشانگر برای ترتیب بایت هستند. جمع‌بندی همان طور که گفته شد کامپیوترها برای اینکه بتوانند اطلاعات نوشتاری، صوتی و تصویری را پردازش کنند به کدهایی که به صورت اعداد و ارقام باشد نیاز دارد. برای این کدگذاری روش‌های مختلفی از جمله ASCII وجود دارد. یکی از روش‌های استاندارد و مشترک در بین زبان‌های مختلف جهان می‌توان به یونی‌کُد اشاره نمود. یونی‌کُد هم برای کدگذاری از سه روش مختلف استفاده کرده است که UTF-8 رایج‌ترین و کاربردی‌ترین است. دلیل محبوبیت بالای این روش کدگذاری سازگاری با ASCII است. UTF-8 تمامی کاراکترهای ASCII را تنها در یک بیت قرار می‌دهد. پس می‌توان گفت که UTF-8 هم با نسخه‌های قدیمی کدگذاری سازگار است و هم برای زبان‌های لاتین بهینه‌تر است.\n","date":"Oct 11, 2017","img":"","permalink":"/posts/unicode-info/","series":[],"tags":["Unicode","ASCII"],"title":"یونی‌کُد (Unicode) چیست؟"},{"categories":["General"],"content":"یکی از مهم‌ترین ساز و کارهایی که باید از سوی دانشجویان علوم کامپیوتر درک گردد پشته‌ی فراخوانی تابع است (گاهی اوقات تحت عنوان پشته‌ی اجرای برنامه نیز شناخته می‌شود). این ساختمان داده – که در پشت صحنه کار خود را انجام می‌دهد – ساز و کار فراخوانی و بازگشت توابع و همچنین ایجاد، نگهداری و انهدام متغیرهای خودکار توابع فراخوانی‌شده را نیز پشتیبانی می‌کند.\nبرای درک نحوه‌ی انجام فراخوانی تابع در زبان‌های برنامه‌نویسی ابتدا باید به بررسی یک ساختمان داده به نام پشته (Stack) بپردازیم. پشته را می‌توانید مانند تعدادی بشقاب که روی هم قرار گرفته‌اند در نظر بگیرید. هنگامی که یک بشقاب بر روی این توده قرار داده می‌شود، معمولا در بالای بشقاب‌ها گذاشته می‌شود (به این عمل گذاشتن یا پوش push کردن بشقاب در پشته می‌گویند). به طور مشابه، هنگامی که یک بشقاب از توده برداشته می‌شود، معمولا از بالای بشقاب‌ها برداشته می‌شود (به این عمل برداشتن یا پاپ pop کردن بشقاب از پشته می‌گویند). پشته‌ها به عنوان ساختمان‌های داده‌ای LIFO (Last-In, First-Out) شناخته می‌شوند یعنی آخرین آیتمی که در پشته گذاشته می‌شود (push) اولین آیتمی است که از پشته برداشته می‌شود (pop). همانطور که در تصویر می‌بینیم، این رفتار LIFO دقیقا همان کاری است که تابع، زمان بازگشت به تابع فراخواننده‌ی خود انجام می‌دهد. هنگامی که یک تابع فراخوانی می‌شود، ممکن است قبل از آنکه مقداری را بازگرداند، توابع دیگری را فراخوانی کند، به همین ترتیب این توابع نیز ممکن است پیش از بازگردان یک مقدار به تابع فراخواننده‌ی خود، توابع دیگری را فراخوانی کنند. هر تابع در نهایت باید کنترل را به تابع فراخواننده‌ی خود باز گرداند. بنابراین، باید آدرس‌های بازگشت را که هر تابع برای بازگرداندن کنترل به تابع فراخواننده‌ی خود به آن‌ها نیاز دارد پیگیری و حفظ نماییم. پشته‌ی فراخوانی تابع یک ساختمان داده‌ی کامل برای اداره‌ی این اطلاعات است. هر زمان که یک تابع اقدام به فراخوانی تابع دیگر می‌کند، یک ورودی به داخل پشته push می‌شود. این ورودی، یک قاب پشته (Stack Frame) یا یک رکورد فعالسازی (activation record) نامیده می‌شود و حاوی آدرس بازگشتی است که تابع فراخوانده‌شده برای بازگشت به تابع فراخواننده‌ی خود به آن نیاز دارد. قاب پشته حاوی یک سری اطلاعات دیگر نیز هست که به زودی در مورد آن‌ها بحث خواهیم کرد. اگر تابع فراخوانده‌شده، بجای فراخوانی تابع دیگری قبل از بازگشت، به مکان فراخوانی شدنش بازگردد، قاب پشته‌ی فرخوانی تابع pop می‌شود و کنترل به آدرس بازگشت، در قاب پشته pop شده منتقل می‌گردد. از مزایای پشته‌ی فراخوانی این است که هر تابع فراخوانی‌شده اطلاعات مورد نیاز خود برای بازگشت به فراخواننده‌ی خود را در بالای پشته‌ی فراخوانی می‌یابد و اگر یک تابع یک فراخوانی به تابع دیگری انجام دهد، یک قاب پشته برای فراخوانی تابع جدید در پشته‌ی فراخوانی push می‌شود. بنابراین، آدرس بازگشت مورد نیاز برای بازگشت تابع جدیدا فراخوانی‌شده به فراخواننده‌ی خود اکنون در بالای پشته قرار گرفته است. قاب‌های پشته یک وظیفه‌ی مهم دیگری نیز بر عهده دارند. اغلب توابع دارای متغیر‌های خودکار مثل پارامترها و متغیرهای محلی که تابع اعلان می‌نماید، هستند. متغیرهای خودکار باید در زمان اجرای یک تابع وجود داشته باشند. این متغیرها حتی اگر تابع اقدام به فرخوانی توابع دیگر نماید نیز باید در حالت فعال باقی بمانند. البته هنگامی که یک تابع فراخوانده‌شده به فراخواننده‌ی خود بر می‌گردد، متغیرهای خودکار تابع فراخوانده‌شده باید از بین بروند. قاب پشته‌ی تابع فراخوانده‌شده یک مکان کامل و مطلوب جهت رزرو حافظه برای برای متغیرهای خودکار تابع فراخوانده‌شده است. این قاب پشته مادامی که تابع فراخوانده‌شده فعال است وجود دارد. هنگامی تابع فراخوانده‌شده به فراخواننده خود بر می‌گردد و دیگر نیازی به متغیرهای خودکار محلی خود ندارد، قاب پشته‌ی آن از درون پشته pop می‌شود، در این حالت متغیرهای خودکار محلی برنامه، دیگر شناخته شده نیستند. البته میزان حافظه در یک کامپیوتر محدود است، از این رو تنها میزان مشخصی از حافظه می‌تواند برای ذخیره‌ی رکوردهای فعالسازی در پشته‌ی فراخوانی تابع بکار برده شود. اگر تعداد فراخوانی‌های تابع صورت گرفته بیش از ظرفیت ذخیره‌سازی رکوردهای فعالسازی در پشته‌ی فراخوانی تابع باشد، یک خطا به نام سرریز پشته (Stack Overflow) رخ می‌دهد.\n","date":"Aug 11, 2017","img":"","permalink":"/posts/function-call-stack-info/","series":[],"tags":["Function Call Stack","Call Stack"],"title":"پشته‌ی فراخوانی توابع (Function Call Stack) چیست؟"},{"categories":["General","UML"],"content":"ایجاد مدل و مدل‌سازی برای بررسی دقیق انواع مختلف سیستم‌های نرم‌افزاری در مقیاس کوچک و بزرگ به کار می‌آید. با ساختن مدل این امکان به شما داده می‌شود با ابعاد مختلف پروژه قبل از ساخت آشنا شوید. گاهی در پروژه‌های بزرگ به دلیل پیچیدگی بیش از حد نمی‌شود سیستم را از جنبه‌های مختلف سنجید. بنابراین برای فهم کامل سیستم، یافتن و نمایش ارتباط بین بخش‌های مختلف آن، به مدل‌سازی می‌پردازیم. UML زبانی برای مدل‌سازی یا ایجاد نقشه‌ی تولید نرم‌افزار است.\nدر دهه‌ی 1980، تعداد رو به رشدی از سازمان‌ها برای ایجاد برنامه‌های خود، شروع به استفاده از برنامه نویسی شی‌گرا (OOP) نمودند. بدین ترتیب فقدان یک فرایند تحلیل و طراحی شی‌گرا استاندارد کاملا احساس گردید. بسیاری از متدولوژیست‌ها مثل Booch، Rumbaugh و Jacobsob – شخصا اقدام به تولید فرایندهای مجزا برای پاسخگویی به این نیاز نموده بودند. هر فرایند دارای نشان‌گذاری یا زبان خاص خود بود (به صورت شکل‌های هندسی مصور)، تا نتایج تحلیل و طراحی را به مخاطب بفهماند. تا اوایل دهه‌ی 1990، سازمان‌های مختلف، و حتی بخش‌های موجود در درون همان سازمان‌ها، فرایندها و نشان‌گذاری‌های خاص خود را مورد استفاده قرار می‌دادند. در عین حال، این سازمان‌ها همچنین خواهان استفاده از ابزارهای نرم‌افزاری بودند که فرایند‌های خاص آن‌ها را پشتیبانی نمایند. فروشندگان نرم‌افزار دریافتند که فراهم نمودن ابزار مناسب برای تعداد زیادی از این پیاده‌سازی‌ها کار بسیار دشواری است. بدیهی بود که یک نشان‌گذاری و پیاده‌سازی استاندارد مورد نیاز بود. در سال 1994، James Rumbaugh در شرکت نرم‌افزاری Rational (که بعدها بخشی از IBM شد) به Grady Booch ملحق گردید، و هر دو فعالیت خود را در جهت یکسان‌سازی پیاده‌سازی‌های متداول آغاز نمودند. به زودی Ivar Jacobson نیز به آن‌ها ملحق شد. در سال 1996، این گروه نسخه‌های اولیه UML را به جامعه‌ی مهندسی نرم‌افزار عرضه کردند و خواهان اعلام نتیجه از سوی آن‌ها شدند. در همان زمان، سازمانی به نام گروه مدیریت شی (OMG) فراخوانی برای یک زبان مدل‌سازی مشترک پیشنهاد داده بود. OMG یک سازمان غیر‌انتفاعی بود که استاندارد‌سازی تکنولوژی‌های شی‌گرا با انتشار راهبردها و مشخصه‌هایی از قبیل UML ترویج و ترقی داد. شرکت‌های متعددی از جمله Microsoft، Oracle، IBM، HP، Rational – که پیش از آن نیاز به یک زبان مدل‌سازی مشترک را احساس کرده بودند، در پاسخ به فراخوان OMG، نسخه UML 1.1 را توسعه دادند و آن را به OMG ارسال نمودند. OMG این پیشنهاد را در سال 1997 پذیرفت و مسئولیت نگهداری مستمر و بازنگری در UML را برعهده گرفت. در سال 2003، OMG نسخه UML 1.5 را عرضه کرد. در سال 2005 نیز با انتشار UML نسخه 2 تغییرات اساسی نسبت به نسخه ابتدایی UML ایجاد گردید و این نسخه پایه‌ی بسیاری از کتاب‌ها، ابزارهای مدل‌سازی شد. پیدایش UML همه چیز را تغییر داد و باعث رشد چشم‌گیر مدل‌سازی تصویری و استفاده گسترده از این زبان شد. UML امروزه نقش یک زبان بین‌المللی را در زمینه‌ی تولید نرم‌افزار بر عهده دارد. موسسه‌ی آماری گارتنر در سال ۲۰۰۶ تعداد متخصصان فناوری اطلاعات که از UML استفاده می‌نمودند را ده میلیون نفر برآورد نمود و همچنین تخمین زده است که در سال ۲۰۰۸ هفتاد درصد شرکت‌های تولید نرم‌افزار در سراسر دنیا از UML استفاده کرده‌اند. در حال حاضر UML بیشترین استفاده را در میان رویه‌های تصویری برای مدل‌سازی سیستم‌های شی‌گرا دارد. این زبان رویه‌های متداول نشان‌گذاری را کاملا به صورت یکپارچه در آورده است. آن‌هایی که طراحی سیستم‌های نرم‌افزاری شی‌گرا را انجام می‌دهند از این زبان (به صورت اشکال هندسی) برای مدل کردن سیستم‌های خود استفاده می‌نمایند. یکی از ویژگی‌های جذاب UML انعطاف‌پذیری آن است. UML توسعه‌پذیر است (یعنی توان بهبود یافتن توسط مشخصه‌های جدید را دارد) و مستقل از هر فرایند تحلیل و طراحی شی‌گرای خاص است. باید توجه داشت که UML تنها یک زبان نمادگذاری و مدل‌سازی است و به عنوان یک متدولوژی توسعه نرم‌افزار استفاده نمی‌شود. اما اکنون تمامی توسعه‌دهندگان می‌توانند طراحی‌های خود را با استفاده از یک مجموعه‌ی استاندارد از نشان‌گذاری‌های تصویری بیان نمایند. UML برای استفاده در فرایندهای طراحی شی‌گرا (OOD) طراحی شده است. تعداد فراوانی از چنین فرایندهایی موجود است، که یکی از بهترین‌های آن Rational Unified Process است که توسط شرکت نرم‌افزاری Rational توسعه داده شده است. RUP یک فرایند غنی برای طراحی برنامه‌های قدرتمند صنعتی محسوب می‌گردد. RUP امکان استفاده مؤثرتری از زبان یکپارچه مدل‌سازی (UML) را فراهم می‌سازد. آخرین نسخه UML چهارده گونه نمودار برای مستندسازی مدل‌های سیستم‌ها فراهم می‌آورد، هر مدل یک خصیصه‌ی مجزا از ساختار یا رفتار یک سیستم را مدل می‌کند. هفت نمودار مربوط به ساختار سیستم و هفت نمودار دیگر در ارتباط با رفتار سیستم می‌باشد. نمودارهای ساختاری (Structure Diagrams) نمودار کلاس (Class Diagram) رایج‌ترین نموداری است که در UML استفاده می‌شود. این نمودار یک نمای ایستا (static view) از کلاس‌ها را در یک مدل یا بخشی از یک مدل را نشان می‌دهد. در این نمودار صفات و عملیات کلاس را می‌توان به همراه انواع مختلفی از رابطه‌های بین کلاس‌ها نشان داد. نمودار کلاس نمایی شی‌گرا از یک سیستم را نشان می‌دهد. نمودار شی (Object Diagram) نمودارهای شی از نمودارهای کلاس مشتق می‌شوند، بنابراین نمودارهای شی به نمودارهای کلاس وابسته هستند. این نمودار نمونه‌ای از نمودار کلاس را نشان می‌دهد. مفاهیم اساسی برای نمودارهای کلاس و نمودارهای شی مشابه هستند. نمودارهای شی همچنین دید ایستا از یک سیستم را نشان می‌دهند اما این دید ایستا یک تصویر یا نسخه‌ی فوری از سیستم در یک لحظه خاص است. نمودارهای شیء برای ارائه مجموعه‌ای از اشیاء و روابط آن‌ها به عنوان نمونه استفاده می‌شود. نمودار بسته (Package Diagram) ساختار سلسله مراتبی بسته‌های درون سیستم (که گروه‌هایی از کلاس‌ها هستند) در زمان کامپایل و روابطی که میان بسته‌ها وجود دارد را مدل می‌کند. نمودار ساختار مرکب (Composite Structure Diagram) مشابه نمودار کلاس است با این تفاوت که ساختار داخلی یک شی ترکیبی در زمان اجرا را مدل می‌کند و به طراحان سیستم امکان تجزیه‌ی یک شی ترکیبی به قسمت‌های کوچک‌تر را به صورت سلسله مراتبی می‌دهند. نمودار اجزا (Component Diagram) برای نمایش تصویری از سازمان‌دهی، ترتیب و رابطه‌ی میان اجزا و مولفه‌های سیستم به کار می‌رود. این نمودارها برای ایجاد سیستم‌های قابل اجرا نیز مورد استفاده می‌گیرند. به عبارتی این نمودارها چگونگی تقسیم سیستم به مولفه‌های آن و وابستگی بین مولفه‌های سیستم را توصیف می‌کند. نمودارهای اجزا اغلب برای نشان دادن ساختار سیستم‌های یکپارچه پیچیده، مورد استفاده قرار می‌گیرند. نمودار استقرار (Deployment Diagram) نیازمندی‌های فیزیکی (سخت‌افزاری) زمان اجرای سیستم (مثل کامپیوتر یا کامپیوترهایی که سیستم بر روی آن‌ها مستقر خواهد شد)، نیازمندی‌های حافظه، محیط اجرا و سایر ابزارهایی که سیستم در طی اجرا به آن‌ها نیاز دارد را مدل می‌کند. این نمودار ساختاری، معماری سیستم را در زمان استقرار نرم‌افزار نشان می‌دهد. یک نمودار استقرار کارآمد پارامترهای همچون کارایی، مقیاس‌پذیری، قابلیت نگهداری و قابلیت حمل را کنترل می‌کند. نمودار مشخصات (Profile Diagram) به عنوان مکانیزمی برای گسترش UML استفاده می‌شود که به شما امکان می‌دهد که با افزودن بلوک‌های ساختاری جدید، ایجاد ویژگی‌های جدید و تعیین مفاهیم جدید، UML را گسترش داده و سفارشی کنید تا زبان را برای دامنه مسئله‌ی خاص خود شخصی‌سازی کنید. نمودارهای رفتاری (Behavior Diagrams) نمودار کاربرد (Use Case Diagram) تعاملات میان یک سیستم و موجودیت‌های خارجی (کنش‌گرها) را بر مبنای مورد استفاده آن‌ها مدل می‌کند. نمودار فعالیت (Activity Diagram) فعالیت یک شی را مدل می‌کند و روند کاری (توالی رویدادها) شی در طی اجرای برنامه را نشان می‌دهد. یک نمودار فعالیت، اعمالی را که شی انجام می‌دهد مدل می‌کند و ترتیب انجام این اعمال را از سوی آن مشخص می‌سازد. نمودار حالت (State Machine Diagram) روش‌هایی را که یک شی از طریق آن‌ها وضعیت را تغییر می‌دهند مدل می‌کند. وضعیت یک شی توسط مقادیر تمامی صفات شی در زمان مورد نظر تعیین می‌گردد. هنگامی که یک شی وضعیت را تغییر می‌دهد، ممکن است آن شی در سیستم به شکلی متفاوت رفتار نماید. نمودارهای تعامل (Interaction Diagrams) زیر مجموعه‌ای از نمودارهای رفتاری هستند که بر گردش کنترل و داده‌ها بین چیزهای مختلف در سیستم مدل‌شده تأکید دارند. نمودار توالی (Sequence Diagram) تعاملات میان اشیا یک سیستم را مدل می‌کند اما برخلاف نمودارهای ارتباط، آن‌ها بر زمان وقوع تعامل‌ها تاکید دارند. این نمودارها به نشان دادن ترتیب وقوع تعامل‌ها در زمان اجرای یک عملیات کمک می‌نمایند. نمودار ارتباط (Communication Diagram) تعاملات میان اشیا را با تاکید بر کاری که تعامل‌ها انجام می‌دهند، در یک سیستم مدل می‌کند. نمودار زمان‌بندی (Timing Diagram) فشارها و محدودیت‌های زمانی تحمیل‌شده بر تغییرات میدانی و تعاملات اشیا در یک سیستم را مدل می‌کنند. نمودار چشم‌انداز ارتباط (Interaction Overview Diagram) با ترکیب عناصری از انواع متعدد نمودارهای رفتاری (مثل نمودارهای فعالیت و نمودارهای توالی) چشم‌اندازی از جریان کنترل در سیستم را فراهم می‌نماید. ","date":"Jun 9, 2017","img":"","permalink":"/posts/uml-info/","series":[],"tags":["UML"],"title":"زبان مدل‌سازی یکپارچه (UML) چیست؟"},{"categories":["General","OOP"],"content":"شی‌گرایی یک راه طبیعی تفکر در مورد جهان پیرامون و نوشتن برنامه‌های کامپیوتری است. در دنیای واقعی به هرجا که بنگرید اشیا را مشاهده می‌کنید: اشخاص، حیوانات، گیاهان، اتوموبیل‌ها، هواپیماها، ساختمان‌ها، کامپیوترها و مواردی از این قبیل. انسان‌ها هر روز اشیا را در اطراف خود مشاهده می‌کنند و در مورد آن‌ها به تفکر می‌پردازند.\nاغلب اشیا را به دو دسته تقسیم می‌نماییم: جاندار و بی جان. اشیای جاندار زنده هستند، حرکت می‌کنند و یک سری اعمال انجام می‌دهند. از سوی دیگر، اشیای بی‌جان به خودی خود حرکت نمی‌کنند. اما در هر صورت هر دو نوع شی در یک سری چیزها مشترک هستند. همه‌ی آن‌ها دارای صفاتی می‌باشند (مثلا اندازه، شکل، رنگ و وزن)، و همه‌ی آن‌ها رفتارهایی از خود بروز می‌دهند (مثلا یک توپ قِل می‌خورد، می‌جهد، باد می‌شود و کم باد می‌گردد – یک نوزاد گریه می‌کند، می‌خوابد، می‌خزد، راه می‌رود و چشمان خود را برهم می‌زند – یک اتوموبیل شتاب می‌گیرد، ترمز می‌کند و می‌پیچد). انسان‌ها با مطالعه‌ی صفات اشیا موجود و مشاهده رفتار آن‌ها به کسب اطلاعات در مورد آن‌ها می‌پردازند. اشیای متفاوت می‌توانند دارای صفات مشابه باشند و می‌توانند رفتارهای مشابه از خود بروز دهند. به عنوان مثال، می‌توان میان نوزادان، بزرگسالان و میان انسان‌ها و شامپانزه‌ها شباهت‌هایی یافت. طراحی شی‌گرا (Object-oriented design) اجزای نرم‌افزاری را بر اساس اشیای دنیای واقعی مدل می‌نماید. در حقیقت این روش، مدل‌سازی اشیا توسط صفات، رفتارها و مناسبات مشترک آن‌ها به همان صورتی که ما اشیا دنیای واقعی را توصیف می‌کنیم می‌باشد. طراحی شی‌گرا همچنین ارتباط میان اشیا را مدل می‌کند. دقیقا به همان گونه که افراد به یکدیگر پیغام می‌فرستند (مثلا یک گروه‌بان به یک سرباز دستور می‌دهد)، اشیا نیز از طریق پیغام‌ها با یکدیگر ارتباط برقرار می‌نمایند. مثلا یک شی حساب بانکی ممکن است یک پیغام مبنی بر کاهش پول موجود در خود به یک میزان معین را دریافت نماید. چرا که مشتری آن میزان پول را از حساب خود برداشت نموده است. طراحی شی‌گرا، صفات و اعمال (رفتارها) را در اشیا پنهان (Encapsulate) می‌سازد. اشیا دارای خصوصیت پنهان‌سازی اطلاعات هستند. این بدان معنی است که ممکن است اشیا برقراری ارتباط با دیگری را در میان رابطه‌های خویش تعریف‌شده بدانند، اما آن‌ها اجازه‌ی کسب اطلاع از نحوه پیاده‌سازی سایر اشیا را ندارند. جزییات پیاده‌سازی درون خود اشیا پنهان است. برای نمونه، اگر ما نحوه‌ی استفاده از پدال گاز، پدال ترمز، فرمان و مواردی از این قبیل را بدانیم، می‌توانیم به شکلی کارآمد بدون آن که از جزییات نحوه‌ی عملکرد داخلی سیستم‌های موتور، ترمز و اگزوز آگاهی داشته باشیم، یک اتوموبیل را برانیم. پنهان‌سازی اطلاعات، یک امر حیاتی در مهندسی نرم‌افزار خوب محسوب می‌شود. برنامه‌نویسی با زبان‌هایی که از شی‌گرایی پشتیبانی می‌کنند، برنامه‌نویسی شی‌گرا (Object-oriented programming) نامیده می‌شود. در برنامه‌نویسی شی‌گرا به برنامه‌نویسان امکان پیاده‌سازی یک طراحی شی‌گرا به عنوان یک سیستم نرم‌افزاری کارآمد داده می‌شود. در زبان‌های برنامه‌نویسی شی‌گرا، واحد برنامه‌نویسی کلاس (Class) است که در نهایت اشیا از روی آن نمونه‌سازی (Instantiate) می‌شوند. کلاس‌ها برای اشیا به منزله طرح اولیه برای خانه‌ها است. یک کلاس را می‌توان به عنوان نقشه‌ای برای ساختن یک شی از روی یک کلاس در نظر گرفت. دقیقا همان‌گونه که ما می‌توانیم از روی یک طرح تعداد زیادی خانه بسازیم، می‌توانیم اشیا بسیاری را از روی یک کلاس نمونه‌سازی کنیم. شما نمی‌توانید در طرح یک آشپزخانه اقدام به آشپزی نمایید، بلکه کار آشپزی را در آشپزخانه‌ی موجود در یک خانه انجام می‌دهید. شما نمی‌توانید در طرح یک اتاق خواب بخوابید، بلکه باید در اتاق خواب موجود در یک خانه بخوابید. کلاس‌ها شامل توابعی برای پیاده‌سازی اعمال و داده‌هایی برای پیاده‌سازی صفات می‌باشند. در حقیقت کلاس‌ها دارای مجموعه‌ای از داده‌ها و توابعی هستند که عمل خاصی را بر روی داده‌ها انجام می‌دهند و خدماتی را برای سرویس‌گیرندگان (یعنی سایر کلاس‌ها یا توابعی که از کلاس استفاده می‌نمایند) فراهم می‌نمایند. اجزا داده‌ای یک کلاس تحت عنوان اعضای داده شناخته می‌شوند. برای مثال، یک کلاس حساب بانکی می‌تواند شامل یک شماره حساب و یک موجودی باشد. اجزای تابع یک کلاس تحت عنوان توابع عضو (متد) شناخته می‌شوند. برای مثال، یک کلاس حساب بانکی می‌تواند شامل توابع عضو برای افزایش مبلغ موجودی، کاهش مبلغ موجودی و اعلام موجودی فعلی باشد. کلاس‌ها می‌توانند با سایر کلاس‌ها رابطه داشته باشند. برای مثال، در یک طراحی شی‌گرا از یک بانک، کلاس تحویل‌دار باید با سایر کلاس‌ها مرتبط باشد، کلاس‌هایی از قبیل کلاس \u0026ldquo;مشتری\u0026rdquo;، کلاس \u0026ldquo;حواله‌دهنده\u0026rdquo;، کلاس \u0026ldquo;گاو صندوق\u0026rdquo; و مواردی از این قبیل. این روابط تحت عنوان پیوندها (Associations) شناخته می‌شوند. به عنوان مثالی دیگر در حالتی که اشیا یک کلاس دارای خصیصه‌های یکسان باشند مثل یک کلاس از وسایل نقلیه (اتوموبیل‌ها، کامیون‌ها، واگن‌ها و اسکیت‌ها)، در طراحی شی‌گرا می‌توان از یک کلاس پایه \u0026ldquo;خودرو\u0026rdquo; که شامل ویژگی‌های مشترک بین همه‌ی وسایل نقلیه دارد استفاده نمود. مطمئنا کلاس \u0026ldquo;خودرو\u0026rdquo; ویژگی‌های کلی‌تری از نسبت به هر نوع خاص وسیله نقلیه دارد و همه‌ی وسایل نقلیه می‌توانند از این کلاس به صورت مشترک استفاده نماید یا به اصلاح از آن ارث (Inheritance) ببرند. پیاده‌سازی نرم‌افزار بر اساس کلاس، امکان استفاده‌ی مجدد از کلاس‌ها را در طراحی سیستم‌های نرم‌افزاری بعدی فراهم می‌آورد. مجموعه کلاس‌های مرتبط با هم اغلب به صورت قطعه برنامه‌هایی با قابلیت استفاده مجدد در یک گروه دسته‌بندی می‌شوند. دقیقا همان‌گونه که یک دلال معاملات ملکی می‌گوید سه عامل تاثیر‌گذار بر قیمت املاک \u0026ldquo;مکان، مکان، مکان\u0026rdquo; است، افراد حاضر در جامعه‌ی توسعه‌ی نرم‌افزار هم اغلب می‌گویند سه عامل تاثیر‌گذار بر آینده‌ی توسعه‌ی نرم‌افزار \u0026ldquo;استفاده مجدد، استفاده مجدد، استفاده مجدد\u0026rdquo; است. استفاده مجدد از کلاس‌های موجود در هنگام ساختن کلاس‌ها و برنامه‌های جدید باعث صرفه‌جویی در زمان، هزینه و کار مورد نیاز می‌گردد. همچنین استفاده مجدد به برنامه‌نویسان در جهت ایجاد سیستم‌های قابل اطمینان‌تر و کارآمدتر کمک می‌کند، زیرا کلاس و قطعه برنامه‌های موجود اغلب تست، اشکال‌زدایی و بررسی کارآمدی را به شکلی جامع پشت سر گذاشته اند. با استفاده از فناوری شی، شما می‌توانید بخش اعظم نرم‌افزار جدید مورد نیاز خود را با ترکیب نمودن کلاس‌های موجود بسازید. هر کلاس جدیدی که شما ایجاد می‌نمایید پتانسیل تبدیل شدن به یک سرمایه‌ی نرم‌افزاری با ارزش را دارد، بنابراین شما و سایر برنامه‌نویسان می‌توانید از آن مجددا برای تسریع و بهبود با کیفیت فرایندهای توسعه نرم‌افزار در آینده استفاده کنید.\n","date":"May 12, 2017","img":"","permalink":"/posts/oo-info/","series":[],"tags":["OOP","OOD","Object Oriented","Object"],"title":"شی‌گرایی (Object Oriented) چیست؟"},{"categories":["General"],"content":"چرخه‌ی عمر توسعه‌ی نرم‌افزار (Software Development Life Cycle) مراحلی را شامل می‌شود که نرم‌افزار در طی آن‌ها توسعه می‌یابد یعنی از زمانی که ایده آن مطرح می‌شود تا زمانی که استفاده از آن متوقف می‌گردد.\nاین مراحل شامل: برنامه‌ریزی، تحلیل، طراحی، پیاده‌سازی، تست و اشکال‌زدایی، استقرار و نگهداری است. مدل‌های متعددی برای چرخه‌ی عمر توسعه‌ی نرم‌افزار وجود دارد، که هر کدام اولویت‌ها و ویژگی‌های خود را برای تعیین این موضوع که مهندسان نرم‌افزار چه زمانی و چگونه باید هر یک از این مراحل را انجام دهند دارا می‌باشند. مدل‌های آبشاری (waterfall) این مراحل را یک بار به صورت متوالی انجام می‌دهند، در حالی که مدل‌های تکراری (iterative) ممکن است یک یا چند مرحله را در طی چرخه‌ی عمر یک محصول چندین بار تکرار نمایند. چرخه‌ی عمر توسعه‌ی نرم‌افزار راهی برای اندازه‌گیری و بهبود روند توسعه است. این امر اجازه می‌دهد تا تجزیه و تحلیل دقیق در هر مرحله از روند توسعه انجام شود. این به نوبه‌ی خود به شرکت‌ها کمک می‌کند تا در هر مرحله کارایی خود را به حداکثر برسانند. با افزایش قدرت محاسبات، تقاضای بیشتری برای نرم‌افزار و توسعه‌دهندگان ایجاد می‌شود. شرکت‌ها باید هزینه‌ها را کاهش دهند، نرم‌افزار را سریع‌تر تحویل دهند و نیاز مشتریان خود را برآورده یا از آن‌ها فراتر روند. چرخه‌ی عمر توسعه‌ی نرم‌افزار با شناسایی ناکارآمدی و هزینه‌های بالاتر و رفع صحیح عملکرد آن‌ها به دستیابی به این اهداف کمک می‌کند.\nمراحل چرخه‌ی عمر توسعه‌ی نرم‌افزار برنامه‌ریزی در مرحله‌ی برنامه‌ریزی، مهندسان نرم‌افزار با تجربه، مشکل و دامنه‌ی سیستم‌های موجود را تعریف نموده و اهدافی را برای ساخت سیستم‌های جدید تعیین می‌کنند. مهم‌ترین هدفی که مرحله‌ی برنامه‌ریزی به آن می‌رسد این است که برنامه‌ی زمان‌بندی و هزینه‌ی پروژه را ارائه می‌دهد. عدم برنامه‌ریزی یکی از رایج‌ترین دلایلی است که باعث می‌شود توسعه‌ی نرم‌افزار با شکست مواجه شود. طراحی تضمین کیفیت نرم‌افزار و همچنین شناسایی ریسك‌ها و خطرات بالقوه پروژه نیز در مرحله برنامه‌ریزی انجام می‌گیرد. نتیجه‌ی مطالعات و امکان‌سنجی‌ها موجب بدست آوردن دیدگاه‌های مختلف فنی خواهد بود كه می‌تواند باعث پیاده‌سازی موفقیت‌آمیز پروژه با حداقل ریسک گردد. ###تحلیل تحلیل‌گران سیستم، نیازمندی‌هایی را جمع‌آوری می‌کنند که محدوده‌ی مسئله‌ی مورد نظر را مشخص کند. فرایند جمع‌آوری نیازمندی‌ها یک عمل پایه‌ای در مرحله‌ی تحلیل از چرخه‌ی عمر توسعه‌ی نرم‌افزار است. در مرحله‌ی تحلیل، مهندسان نرم‌افزار یک سند \u0026ldquo;مشخصات نیازمندی‌های نرم‌افزار\u0026rdquo; (Software Requirement Specification) یا به اختصار (SRS) ایجاد می‌کنند. سند SRS شامل تمامی نیازهای نرم‌افزار، سخت‌افزار و شبکه خواهد بود که در نرم‌افزار سفارشی ایجاد‌‌شده مورد نیاز خواهد بود. SRS چگونگی تعامل نرم‌افزار را با سخت‌افزار، رابط‌های خارجی، سرعت کار، زمان پاسخ‌گویی سیستم، قابلیت حمل نرم‌افزار در سیستم‌عامل‌های مختلف، قابلیت اطمینان‌، سرعت بازیابی پس از خرابی‌، امنیت‌، کیفیت‌، محدودیت‌ها و غیره را تعریف می‌کند.\nطراحی مهندسان نرم‌افزار (اگر بخواهیم دقیق‌تر بگوییم، طراحان سیستم) باید سند نیازمندی‌ها را مورد تحلیل قرار داده و سیستم را قبل از پیاده‌سازی طراحی نمایند. در طی این مرحله، طراحان سیستم بر روی درک سند نیازمندی‌ها تمرکز می‌کنند تا الگوی سطح بالایی تولید نمایند که کارهای خواسته‌شده از سیستم را تشریح نماید. خروجی مرحله‌ی طراحی باید نحوه‌ی ساخته‌شدن سیستم را به صورت واضحی مشخص کند تا این نیازمندی‌ها را برآورده سازد. مدل‌های مختلفی به منظور طراحی نرم‌افزارها وجود دارد که طراحان سیستم برای طراحی نرم‌افزارها از آن استفاده می‌کنند. تحلیل و طراحی شی‌گرا (OOAD) یکی از مدل‌هایی است که با استفاده از آن می‌توان سیستم را از دیدگاه شی‌گرایی مورد تحلیل و طراحی قرار داد. در حالت ایده‌آل، یک گروه باید بر روی یک روند کاملا مشخص در حل مسئله و یک روش واحد برای مرتبط ساختن نتایج آن رویکرد به دیگر قسمت‌ها به توافق دست یابد. با توجه به اینکه نحوه‌ی استفاده از تحلیل و طراحی شی‌گرا بسیار متنوع است، امروزه از زبان مدل‌سازی یکپارچه (UML) به منظور مرتبط ساختن نتایج کارها با یکدیگر استفاده می‌شود. طراحان سیستم معمولا براساس نیازمندی‌های مندرج در مستند SRS، یك و یا دو طرح پیشنهادی را جهت تعیین نهایی معماری مورد نیاز انتخاب و در مستند دیگری بنام \u0026ldquo;سند مشخصات طرح\u0026rdquo; (Document Design Specification) یا با اختصار (DDS) ارائه و پیشنهاد می‌نمایند. سند مذکور توسط همه‌ی ذینفعان و براساس معیارهای گوناگون نظیر ارزیابی ریسک، پیمانگی طرح (modularity)، قابلیت استفاده در شرایط مختلف، محدودیت زمانی و بودجه مورد بررسی و ارزیابی قرارگرفته و سرانجام بهترین طراحی جهت تولید نرم‌افزار انتخاب می‌گردد. در طراحی نرم‌افزار تمامی جنبه‌های معماری و همچنین روش‌های ارتباطی و جریان ارسال و دریافت داده‌ها از سامانه‌های دیگر (در صورت وجود آن‌ها) مد نظر قرار می‌گیرد. در معماری پیشنهادی، می‌باید طراحی داخلی همه‌ی مدل‌ها و پیمان‌ها به‌نحوی کاملا واضح و آشکار و با ذکر تمامی جزییات در سند مشخصات طرح (DDS) درج شود. در برخی موارد نیز در این مرحله یک به اصطلاح نمونه‌ی اولیه‌ی محصول (Prototype) تولید می‌شود تا بدین وسیله مناسب‌ترین روش برای توسعه‌‌ی محصول نهایی اتخاذ گردد که خروجی این مرحله مستنداتی شامل لیستی از الگوها و کامپوننت‌های انتخاب‌شده برای توسعه‌ی محصول و در برخی موارد قطعه‌ کدی مربوط به نمونه‌ی اولیه می‌باشد که به عنوان نقطه‌ی شروعی برای پیاده‌سازی نرم‌افزار مورد استفاده قرار می‌گیرد.\nپیاده‌سازی این مرحله شامل ساختن نرم‌افزار می‌شود. در این مرحله از چرخه‌ی حیات توسعه‌ی نرم‌افزار، روند عملیاتی آغاز و نرم‌افزار تولید می‌گردد. مدل‌های مختلف پیاده‌سازی نرم‌افزار وجود دارد که تیم توسعه برای ساخت نرم‌افزار از آن‌ها پیروی می‌کند (مانند برنامه‌نویسی شی‌گرا (OOP)). مهندسین نرم‌افزار تخصصی برای درک بهتر ساخت‌وساز به مستندات تهیه‌شده در مراحل قبل مراجعه می‌کنند. در حالت ایده‌آل، تمام برنامه‌ریزی‌های قبلی که در مراحل قبلی انجام شده باید فرایند ساخت نرم‌افزار واقعی را نسبتا آسان کند. یک پروژه‌ی کوچک ممکن است توسط یک توسعه‌دهنده نوشته شود، در حالی که یک پروژه‌ی بزرگ ممکن است بین چندین تیم تقسیم گردد. در این مرحله از برنامه Source Code Management استفاده کنید. این سیستم‌ها به توسعه‌دهندگان کمک می‌کنند تا تغییرات کد را پیگیری کنند. آن‌ها همچنین به اطمینان از سازگاری بین پروژه‌های مختلف تیمی و اطمینان از تحقق اهداف کمک می‌کنند.\nتست و اشکال‌زدایی تست یک برنامه قبل از در دسترس قرار دادن آن برای کاربران بسیار مهم است. بسیاری از تست‌ها می‌توانند به‌صورت خودکار انجام شوند، مانند تست‌های امنیتی. تست‌های دیگر فقط در یک محیط خاص قابل انجام است؛ ایجاد یک محیط تولید شبیه‌سازی شده برای استقرارهای پیچیده را در نظر بگیرید. تست باید عملکرد صحیح هر فرایند را تضمین کند. قسمت‌های مختلف برنامه نیز باید تست شوند تا به طور یکپارچه با هم کار کنند: آزمون عملکرد، برای کاهش تاخیر در پردازش. مرحله‌ی تست به کاهش تعداد اشکالاتی که کاربران با آن روبرو هستند کمک می‌کند. این امر منجر به رضایت بیشتر کاربر و استفاده بهتر می‌شود.\nاستقرار در مرحله استقرار، برنامه در دسترس کاربران قرار می‌گیرد. بسیاری از شرکت‌ها ترجیح می‌دهند مرحله استقرار را به صورت خودکار انجام دهند. این می‌تواند به سادگی درگاه پرداخت و لینک بارگیری (download) در وب‌سایت شرکت باشد. همچنین ممکن است بارگیری یک برنامه کاربردی در تلفن هوشمند باشد. استقرار نیز می‌تواند پیچیده باشد. به‌روزرسانی یک بانک اطلاعاتی در کل شرکت به یک برنامه تازه توسعه‌یافته یکی از این موارد است. از آنجا که چندین سیستم دیگر توسط بانک اطلاعاتی استفاده می‌شود، ادغام این ارتقا می‌تواند زمان و تلاش بیشتری ببرد. نگهداری و پشتیبانی این مرحله عملکرد نرم‌افزار را از نظر کارآیی بیش‌تر و خطاهای کم‌تر تایید می‌کند. در صورت لزوم، به کاربران در مورد نحوه‌ی بهره‌برداری از نرم‌افزار و نحوه‌ی عملکرد نرم‌افزار آموزش داده می‌شود و یا به آن‌ها کمک می‌شود. این نرم‌افزار به‌موقع، با به‌روزرسانی کد با توجه به تغییراتی که در محیط کاربر نهایی یا تکنولوژی ایجاد می‌شود، حفظ می‌شود. این مرحله ممکن است با اشکالات پنهان و مشکلات ناشناخته در دنیای واقعی روبرو شود. نگهداری و ارتقای نرم‌افزاری برای پوشش، مسائل پوشش داده‌ نشده یا نیازمندی‌های تازه‌ای که ممکن است به وجود آیند مدت خیلی زیادی حتی بیشتر از زمان اولیه‌ی تولید نرم‌افزار زمان بگیرد. این مرحله ممکن است نیاز باشد تا کدهای برنامه‌نویسی تازه‌ای که در طراحی اصلی برنامه نیز دیده نشده اضافه شود تا مسائل و مشکلات دیده‌ نشده حل شوند یا ممکن است کاربر درخواست عملیات اصلی دیگری کند و برنامه‌نویسی‌های تازه‌ای برای برآورده کردن نیازهای جدید انجام گیرد. مرحله‌ی نگهداری شامل مواردی همچون ارائه‌ی نسخه‌ی جدید از نرم‌افزار یا افزودن ویژگی‌های جدید به آن بر اساس نیازهای متغیر کاربران می‌باشد که در طول زمان تغییر کرده و نیازمند بازبینی مجدد می‌باشند و از همین روی می‌توان گفت که چرخه‌ی حیات توسعه‌ی نرم‌افزار نقطه‌ی پایانی نداشته و مرحله‌ی نگهداری نیز به عنوان نقطه‌ی شروع مجدد این چرخه می‌باشد بدین معنی که تمامی مراحل فوق به منظور رفع نیازهای کاربران و ارائه‌ی محصولی باکیفیت می‌باید به طور مداوم تکرار شوند.\n","date":"May 10, 2017","img":"","permalink":"/posts/sdlc-info/","series":[],"tags":["Software","Software Life Cycle","SLC"],"title":"چرخه‌ی عمر توسعه‌ی نرم‌افزار (SDLC) چیست؟"},{"categories":["General"],"content":"پردازنده‌های گرافیکی به دلیل ماهیت ساختاری و هدفی که دنبال می‌كنند‌، توانایی‌های فوق‌العاده‌ای در زمینه پردازش ‌موازی و محاسبات ممیز شناور (Floating Point) دارند و به دلیل برخورداری از هسته‌های پردازشی بیشتر با معماری بهینه‌سازی شده برای محاسبات موازی‌، در بسیاری از موارد قدرت محاسباتی بالاتری نسبت به CPU ارائه می‌دهند.\nشکل زیر نمونه‌ای از تفاوت معماری‌های CPU و GPU را نشان می‌دهد. مطابق بررسی‌های انجام‌شده‌، قدرت محاسباتی یک پردازنده گرافیکی تسلا‌، چیزی بالاتر از پانصد برابر قدرت یک پردازنده چهار هسته‌ای اینتل است. به این نکته توجه داشته باشید که پردازنده‌های گرافیکی به دلیل معماری خاص و هدف یگانه‌ای که دارند از چنین توانایی‌هایی برخوردار بوده و معماری آن‌ها برای پیاده‌سازی یک CPU مناسب نیست. زیرا با توجه به معماری کنونی پلتفرم x86، دستگاه‌ها و تجهیزات مختلفی در سیستم موجود هستند که مدیریت آن‌ها بر عهده پردازنده بوده و برای حفظ ارتباطات مناسب و مدیریت جامع، CPU ناگزیر از داشتن چنین معماری و به تبع آن پردازش کندتری است. با توجه به مطالب ذکر شده و مفاهیم پایه‌ای موازی‌سازی، پردازنده‌های گرافیکی را می‌توان پردازنده‌هایی بهینه‌ شده در راستای موازی‌سازی وظایف (Task Parallelism) و داده‌ها (Data Parallelism) دانست. قدرت محاسبات قوی ریاضی GPU آن را برای استفاده در محاسبات داده‌های با حجم بالا چون پردازش تصویر و ویدیو، کدگذاری و کدگشایی تصاویر و تشخیص الگو بسیار کارا كرده است. این کارایی باعث شد تا فناوری‌هایی برای استفاده از قدرت GPU در محاسباتی خارج از بازی‌ها پا به عرصه وجود بگذارند و محصولات مختلفی بر پایه آن‌ها روانه بازار شود. فناوری CUDA (مخفف Compute Unified Device Architecture هست) از شرکت Nvidia نخستین و موفق‌ترین فناوری این چنینی است که مفاهیم جدید بسیاری را در افزایش سرعت محاسبات با کاربردهای مختلف بر پایه استفاده از GPU مطرح كرده است. برای استفاده از پلتفرم CUDA و برنامه‌نویسی برای استفاده از قدرت GPU، محصولات مختلفی تولید و عرضه شده‌اند که عموماً در راستای توسعه کد در محیط‌های برنامه‌نویسی پیشرفته به‌کار می‌روند. با این حال، کاربران بسیاری در محیط‌های علمی صنعتی وجود داشتند که لازم بود بدون داشتن دانش کافی در برنامه‌نویسی پیشرفته، بتوانند از قدرت محاسباتی GPU و امکانات CUDA استفاده كرده و سرعت محاسبات خود را در زمینه‌های تحقیقاتی افزایش دهند. برنامه‌نویسی موازی توسط CUDA مزایای برنامه‌نویسی روی GPU موضوعی نیست که به توضیح نیاز داشته باشد. این که می‌توان با استفاده از پردازنده‌های گرافیکی، سرعت بعضی از برنامه‌ها را تا ده‌ها برابر افزایش داد، در یك كلام، فوق‌العاده است. با این حال، تا مدت‌ها این مزیت به‌وسیله یک مانع بزرگ محدود شد. این مانع در واقع شیوه برنامه‌نویسی برای GPUها بود. برنامه‌نویسانی که با زبان‌هایی مانند C، ++C ، جاوا، زبان‌های مبتنی بر .NET، پایتون و بسیاری از زبان‌های برنامه‌نویسی معمول دیگر آشنا بودند، به‌طور طبیعی علاقه‌ای به یادگیری زبان یا پلتفرم جدیدی نداشتند. آن‌ها ترجیح می‌دانند که بتوانند به وسیله همین زبان‌ها برای پردازنده‌های گرافیکی نیز برنامه نویسی كنند. این دقیقاً همان چیزی است که CUDA را محبوب کرده است. با استفاده از این معماری شما می‌توانید برنامه‌ خود را با زبان C نوشته و سپس روی پردازنده گرافیکی اجرا كرده و از سرعت اجرای آن لذت ببرید. مورد مهم دیگر وجود پلتفرمی بود که بتواند روی دستگاه‌های مختلف اجرا شود. CUDA با این شعار که می‌تواند برای شما سطحی قابل‌قبول از کارایی و مقیاس‌پذیری را در یک زمان به ارمغان آورد، وارد بازار برنامه‌نویسی شد. درباره این معماری گفته می‌شود‌: «CUDA معماری‌ای است که به جای محدود‌کردن شما توسط کارایی یک سری کتابخانه، اجازه می‌دهد کار مورد نظرتان را انجام دهید.» با وجود این‌که CUDA روی تراشه‌های گرافیكی اجرا می‌شود، در واقع برنامه‌نویسی CUDA با برنامه‌نویسی GPGPU تفاوت دارد. درگذشته، نوشتن نرم‌افزار برای GPU به این معنی بود که به زبان GPU برنامه بنویسید. در مقابل، همان‌طور که عنوان شد، CUDA به شما اجازه می‌دهد با زبان‌های معمول برنامه‌ای بنویسید که می‌تواند روی GPU نیز اجرا شود. همچنین به دلیل آن‌که CUDA می‌تواند نرم‌افزار شما را به صورت مستقیم روی سخت افزار گرافیکی کامپایل کند، کارایی به دست آمده نیز افزایش پیدا می‌کند. اما مزیت اصلی CUDA چیست؟ به طور کلی، مهم‌ترین فایده‌ای که استفاده از پردازنده‌های گرافیکی برای توسعه‌دهنده در پی دارد، توانایی اجرای نخ‌های پردازشی بسیار زیاد در یک زمان است. به این ترتیب، اگر برنامه شما به گونه‌ای باشد که از Taskهای بسیار زیاد و سبک تشکیل شده باشد، یعنی تعداد Taskها بسیار بالا، اما میزان نیاز آن‌ها به پردازنده کم باشد، CUDA می‌تواند عملکردی خیره‌کننده را برای شما به ارمغان بیاورد. البته توانایی‌های کارت‌های گرافیکی روز به روز در حال افزایش است. به عنوان مثال، بورد‌های جدید شامل پهنای باند حافظه بالاتر، انتقال داده غیرهمزمان، عملیات اتمیک و محاسبات Floating Point نیز می‌شوند که می‌تواند دست برنامه‌نویس را بازتر كند. قبل از شروع برنامه‌نویسی برای CUDA باید با چند موضوع آشنا شویم‌:\nهر برنامه CUDA در واقع برنامه سریالی است که شامل هسته‌های موازی می‌شود. کد سریال زبان C در درون نخ‌های پردازشی میزبان یا همان Thread های CPU اجرا می‌شود. هسته موازی کد C در درون تعداد زیادی از نخ‌های پردازشی دستگاه CUDA (یا همان نخ‌های پردازشی GPU) اجرا می‌شوند. هسته در‌واقع به معنای تعداد زیادی از نخ‌های پردازشی همروند است. در هر زمان یک هسته روی دستگاه اجرا می‌شود. نکته اصلی اینجا است که هر هسته توسط تعداد زیادی از نخ‌های پردازشی اجرا می‌شود. به این ترتیب، همه نخ‌های پردازشی در حال اجرای یک کد هستند، اما داده‌های مربوط به هر کدام متفاوت است. خود نخ‌های پردازشی در داخل بخش‌های بزرگ‌تری به نام بلاک‌های نخ‌پردازشی قرار می‌گیرند. هر هسته در واقع گریدی از بلاک‌های نخ‌پردازشی است. بلاک‌های نخ‌پردازشی نمی‌توانند با یکدیگر همزمان‌سازی شوند. به این ترتیب، آن‌ها می‌توانند به هر ترتیبی اجرا شوند‌: چه سریال و چه موازی. حال می‌توان فلسفه ایجاد بلاک را درک كرد. هر بلاک در یک زمان به یک پردازنده (یا یک هسته پردازنده) نسبت داده‌می‌شود. پس اگر پردازنده ما چهار هسته داشته باشد، در هر زمان می‌تواند چهار بلاک از نخ‌های پردازشی را با یکدیگر اجرا كند. OpenCL و CUDA OpenCL، رقیب CUDA، در سال 2009 به منظور ارائه استانداردی برای محاسبات ناهمگن که محدود به پردازنده‌های AMD ،Intel و Nvidia نباشد، توسط شرکت Apple و Khronos Group راه اندازی شد. در حالی که OpenCL به دلیل چند سکویی و عمومی بودن محبوب است، اما در پردازنده‌های Nvidia به خوبی CUDA عمل نکرده است و از بسیاری کتابخانه‌های یادگیری ماشین پشتیبانی نمی کند یا فقط پس از انتشار آن توسط CUDA از آن پشتیبانی می کند.\n","date":"Mar 2, 2017","img":"","permalink":"/posts/cuda-info/","series":[],"tags":["CUDA","GPU","NVIDIA"],"title":"CUDA چیست؟"},{"categories":["General"],"content":"اعداد صحیح برای شمارش مناسب هستند، اما گاهی اوقات ما نیاز داریم که اعداد بسیار بزرگ یا اعدادی با جزء کسری را ذخیره کنیم. اعداد اعشاری یا همان اعداد حقیقی برای ارزش‌گذاری عبارت‌هایی كه نیازمند دقت بیشتری هستند، استفاده می‌شوند. برخلاف اعداد صحیح که به آسانی می‌توان آن‌ها را به مقادیر دودویی (binary) تبدیل کرده و در سیستم‌های کامپیوتری استفاده نمود، برای اعداد اعشاری چالش بزرگی پیش رو است تا علاوه بر تبدیل بهینه‌ی اعداد اعشاری به مقادیر دودویی، دامنه‌ی بزرگی از اعداد را هم شامل شود و همچنین دارای دقت و سرعت پردازش بالایی باشد.\nدر علوم کامپیوتر از اصطلاح ممیز شناور (floating point) به عنوان روشی برای نمایش اعداد اعشاری به طوری که محدوده‌ای وسیع از مقادیر را بپذیرند، استفاده می‌شود. اصطلاح \u0026ldquo;ممیز شناور\u0026rdquo; به این واقعیت اشاره دارد که علامت ممیز اعشار می‌تواند \u0026ldquo;شناور\u0026rdquo; باشد. یعنی می‌تواند تعداد متغیری از ارقام، قبل و بعد از علامت ممیز اعشار داشته باشد. در گذشته کامپیوترها‌ی گوناگون روش‌های متفاوتی در پردازش مقادیر ممیز شناور داشتند که این موضوع باعث می‌شد برنامه‌ها بر روی کامپیوترهای مختلف جواب‌های یکسانی را در خروجی نمایش ندهند. به همین منظور در سال 1985 با تلاش گروهی متشکل از ریاضیدانان، دانشمندان علوم کامپیوتر و شرکت‎های تولید سخت‌افزار به سرپرستی William Kahan از دانشگاه کالیفرنیا، استانداردی برای مقادیر ممیز شناور تحت عنوان IEEE754 به سازندگان سخت‌افزارها عرضه شد. با مطرح شدن استاندارد IEEE754 واگرایی شیوه‌های به کار رفته برای نمایش مقادیر ممیز شناور کاهش یافت و بدین ترتیب برنامه‌های نوشته شده برای مقاصد علمی قابل حمل شدند. بسیاری از کامپیوترهای امروزی برای استفاده از مقادیر ممیز شناور از این استاندارد پیروی می‌کنند. طبق این استاندارد روش نمایش و ذخیره‌سازی متغیرهایی از نوع داده ممیز شناور بسیار شبیه به چگونگی نوشتن اعداد با نماد علمی (scientific notation) می‌باشد. نماد علمی یک روش معمول خلاصه‌نویسی در مورد اعداد خیلی بزرگ یا خیلی کوچک می‌باشد. در نگاه اول شاید نماد علمی کمی پیچیده به نظر برسد، اما اگر فهم درستی از نماد علمی داشته باشید، به شما کمک می‌کند تا درک کنید که نوع داده‌ای ممیز شناور چگونه کار می‌کند، و مهم‌تر از آن دارای چه محدودیت‌هایی می‌باشد. نماد علمی در نماد علمی هر عددی می‌تواند، به صورت حاصل‌ضرب دو عدد به شکل: $$ significand * base^{exponent} $$ نوشته ‌شود که در آن base پایه عددی است و نما یا توان (exponent) یک عدد صحیح مثبت یا منفی، و ضریب علمی (significand) یک عدد حقیقی که در مبنای 10 بزرگ‌تر یا مساوی 1 و کوچک‌تر از 10 است می‌باشد. هر چقدر تعداد ارقام در قسمت بعد از اعشار ضریب علمی بیشتر باشد، عدد شما دقیق‌تر می‌باشد. برای مثال در نماد علمی زیر قسمت 1.2 ضریب علمی می‌باشد و عدد 4 توان می‌باشد. این عدد به عدد 12000 ارزیابی می‌گردد. $$ 1.2 * 10^{4} $$ به عنوان مثال جرم زمین را در نظر بگیرید. اگر بخواهیم جرم زمین را در مبنای دهدهی بنویسیم عددی برابر 5973600000000000000000000 کیلوگرم می‌شود. این یک عدد بسیار بزرگ است. همچنین خواندن آن نیز خیلی سخت است (آیا 19 صفر دارد یا 20 صفر؟). اگر جرم زمین را بخواهیم با نماد علمی بنویسیم، خواهیم داشت: $$ 5.9736 * 10^{24} (kg) $$ همانطور که می‌بینید، خواندن نماد علمی آن بسیار ساده‌تر است. همچنین نماد علمی دارای مزیت دیگری است که طی آن می‌توانیم ساده‌تر دو عدد خیلی بزرگ یا دو عدد خیلی کوچک را با هم مقایسه کنیم. این کار تنها با مقایسه توان دو عدد صورت می‌پذیرد. به طوری کلی می‌توان از قواعد زیر برای تبدیل اعداد به نماد علمی استفاده کنید:\nتوان شما از صفر آغاز می شود. ممیز را به سمت چپ ببرید به نحوی که تنها یک رقم غیر از صفر در سمت چپ و قبل از ممیز قرار بگیرد. هر بار که ممیز را یک رقم به سمت چپ منتقل می‌کنید منجر می‌شود تا توان شما 1 واحد افزایش پیدا کند. هر بار که ممیز را یک رقم به سمت راست منتقل می‌کنید منجر می‌شود تا توان شما 1 واحد کاهش پیدا کند. صفرهای قبل از عدد را حذف کنید. صفرهای بعد از عدد را تنها در صورتی حذف کنید که عدد اصلی شما دارای ممیز نباشد. در نماد علمی ترجیح داده می‌شود تا صفرهای بعد از اعشار نگهداری شده و حذف نگردد، چرا که آن صفرها دقت عدد مربوطه را ارائه می‌دهند.\nبرای درک بهتر به مثال‌های زیر توجه کنید: مثال 1 عدد اصلی: 42030 از آخرین رقم در سمت راست شروع کرده و ممیز را 4 رقم به سمت چپ می‌بریم: $$ 4.2030 * 10^{4} $$ هیچ صفری قبل از عدد برای حذف کردن نداریم: $$ 4.2030 * 10^{4} $$ یک صفر در آخرین رقم سمت راست داریم که حذفش می‌کنیم: $$ 4.203 * 10^{4} $$ مثال 2 عدد اصلی: 0.0078900 ممیز را سه رقم به سمت راست می‌بریم تا اولین رقم قبل از ممیز (7) غیر از صفر باشد: $$ 0007.8900 * 10^{3} $$ صفرهای قبل از عدد را از بین می‌بریم: $$ 7.8900 * 10^{3} $$ از آنجا که عدد اصلی ما دارای ممیز می‌باشد، صفرهای سمت راست را حذف نمی‌کنیم: $$ 7.8900 * 10^{3} $$ مثال 3 عدد اصلی: 600.410 ممیز را دو رقم به سمت چپ می‌بریم: $$ 6.00410 * 10^{2} $$ صفر قبل از عدد نداریم که بخواهیم حذفش کنیم: $$ 6.00410 * 10^{2} $$ از آنجا که عدد اصلی ما دارای ممیز می‌باشد، صفرهای سمت راست را حذف نمی‌کنیم: $$ 6.00410 * 10^{2} $$ نماد علمی به صورت دیجیتال یا زمانی که توان به صورت بالانویس مقدور نیست معمولاً با E یا e که معادل «ضربدر ۱۰ به توانِ\u0026hellip;» است نمایش داده می‌شود. به عنوان مثال می‌توان جرم زمین را با نماد علمی به صورت زیر نیز نوشت: $$ 5.9736E24 (kg) $$\nنمایش مقادیر ممیز شناور در IEEE754 استاندارد IEEE754، چند قالب کلی با دقت‌های مختلف از جمله دقت معمولی، دقت مضاعف و دقت‌ مضاعف توسعه‌یافته برای نمایش اعداد ارائه می‌نماید. در این استاندارد، در دقت معمولی از 32 بیت، در دقت مضاعف از 64 بیت و در دقت مضاعف توسعه‌یافته از 128 بیت برای نمایش یک عدد استفاده می‌شود. در روش ارائه‌شده در استاندارد IEEE754 برای نمایش و ذخیره‌سازی انواع ممیز شناور از فرمول زیر استفاده می‌شود: $$ (-1)^{sign} * normalized mantissa * base^{biased exponent} $$ مبنا (base) در نظر گرفته‌شده در استاندارد IEEE754 برابر 2 است. قالب دودویی انواع ممیز شناور نیز به ترتیب زیر است: $$ sign| biased exponent | normalized mantissa $$ علامت (sign) برای اعداد مثبت 0 و برای اعداد منفی 1 می‌باشد و از یک بیت برای نمایش آن استفاده می‌شود. مقدار اعشاری نرمال‌شده (normalized mantissa) بخشی از یک عدد ممیز شناور است که از ارقام معنادار آن تشکیل شده است. بنابراین یک مقدار اعشاری نرمال‌شده عددی است که تنها یک عدد 1 در سمت چپ اعشار دارد. از آنجا همواره عدد سمت اعشار می‌بایست 1 باشد این عدد در فرمت ذخیره‌سازی قرار داده نشده و به صورت پیش‌فرض در نظر گرفته می‌شود. در دقت ساده از 23 بیت، در دقت مضاعف از 52 بیت و در دقت مضاعف توسعه‌یافته از 112 بیت برای نمایش مقدار اعشاری نرمال‌شده استفاده می‌شود. نما یا توان متعادل‌شده (biased exponent) یک عدد صحیح مثبت است که مقدار ثابتی به عنوان bias به آن اضافه شده است تا محدوده توان غیر منفی شود. این مقدار ثابت در دقت معمولی 127، در دقت مضاعف 1023 و در دقت مضاعف توسعه‌یافته 16383 است. همچنین در دقت ساده از 8 بیت، در دقت مضاعف از 11 بیت و در دقت مضاعف توسعه‌یافته از 15 بیت برای نمایش توان متعادل‌شده استفاده می‌شود. به طور مثال ما قصد داریم عدد 5.0- را در به عنوان یک مقدار ممیز شناور معمولی ذخیره کنیم. عدد اصلی در مبنای 2: 0101- برای تبدیل این عدد به یک مقدار اعشاری نرمال‌شده همانند نمایش علمی از آخرین رقم در سمت راست شروع نموده و ممیز را 2 رقم به سمت چپ می‌بریم تا به آخرین 1 برسیم. همچنین به ازای هر رقم یک واحد به توان اضافه می‌کنیم: $$ -01.01 * 10^{2} $$ صفر سمت چپ را نیز حذف می‌کنیم: $$ -1.01 * 10^{2} $$ مقدار ثابت bias را که در دقت معمولی برابر 127 است به توان اضافه می‌کنیم: $$ -1.01 * 10^{2+127} = -1.01 * 10^{129} $$ در عدد به دست آمده مقدار علامت برابر 1، مقدار اعشاری نرمال‌شده برابر 1.01 و توان متعادل‌شده برابر 129 است. از آنجایی که مقدار 1 سمت چپ مقدار اعشاری نرمال‌شده ذخیره نمی‌شود مقدار بیتی عدد -5.0 به صورت زیر است: $$ 0(sign)10000001(exponent)01000000000000000000000(fraction) $$ دقت انواع ممیز شناور از آنجایی که در مقادیر ممیز شناور دقت عدد اعشاری به تعداد بیت قسمت اعشاری محدود شده است در هنگام محاسبات مواردی پیش می‌آید که یک محاسبه مقداری را ایجاد می‌کند که نمی‌تواند دقیقا به وسیله‌ی قالب ممیز شناور ارائه شده توسط IEEE754 نمایش داده شود و سخت‌افزار باید نتیجه را به مقداری که به درستی نمایش داده می‌شود، گرد کند. در استاندارد IEEE754، روش پیش‌فرض برای این کار این است که به نزدیک‌ترین عدد ممکن گرد شود. به عنوان مثال مقدار 1.0 در قالب ممیز شناور به صورت زیر است: $$ 0(sign)01111111(exponent)00000000000000000000000(fraction) $$ که در فرمول IEEE754 به صورت زیر قرار می گیرد: $$ 1.00000000000000000000000(binary) × 2⁰ $$ که برابر عدد زیر در مبنای 2 است: $$ 1.00000000000000000000000 $$ کوچک ترین عددی که می توان به این عدد اضافه یا از این عدد کم کرد برابر با مقدار زیر است: $$ 0.00000000000000000000001(binary) = 0.00000011920928955078(decimal) $$ اگر عددی کوچکتر از 0.00000011920928955078 را جمع یا تفریق کنید، نتیجه تغییر نخواهد کرد زیرا نتیجه به مقدار قبلی گرد می‌شود. وقتی از عدد شناور معمولی استفاده می‌کنید این دقتی است که با عدد 1.0 دارید. در واقع در این مورد مشکل بزرگی نیست زیرا 0.00000011920928955078 برای اکثر برنامه‌ها به اندازه کافی کوچک است. به عنوان مثالی دیگر مقدار 1000000.0 در قالب ممیز شناور به صورت زیر است: $$ 0(sign)10010010(exponent)11101000010010000000000(fraction) $$ که در فرمول IEEE754 به صورت زیر قرار می‌گیرد: $$ 1.11101000010010000000000(binary) × 2¹⁹ $$ که برابر عدد 11110100001001000000.0000 در مبنای 2 است: $$ 11110100001001000000.0000 $$ کوچک‌ترین عددی که می‌توان به این عدد اضافه یا از این عدد کم کرد برابر با مقدار زیر است: $$ 0.0001(binary) = 0.0625(decimal) $$ در این مورد، دقت در مقایسه با زمانی که عدد 1.0 است بسیار کمتر است که این می‌تواند مشکل‌ساز باشد. به عنوان مثال اگر از نوع ممیز شناور با دقت معمولی برای نمایش زمان (ثانیه) از زمان شروع یک برنامه کاربردی استفاده شده باشد و برنامه هر 0.05 ثانیه زمان را شمارش کند، پس از 1000000.0 (یا قبل از آن)، زمان از حرکت باز می‌ایستد!\n","date":"Feb 8, 2017","img":"","permalink":"/posts/float-info/","series":[],"tags":["Float","Floating-point","Scientific Notation","IEEE754"],"title":"ممیز شناور (Floating Point) چیست؟"},{"categories":["General"],"content":"UUID اختصار عبارت Universally Unique Identifier به معنای شناسه منحصر به فرد جهانی می‌باشد. به‌جای این اصطلاح از GUID که اختصار عبارت Globally Unique Identifier به معنای شناسه منحصر به فرد عمومی نیز استفاده می‌شود. GUID یک اصطلاح صنعتی است که توسط شرکت مایکروسافت برای ارائه یک شماره مرجع که در هر زمینه‌ای منحصر به فرد است، تعریف شده است در حالی که در محیط آکادمیک و در استانداردها از اصطلاح UUID استفاده شده است. هر دو اصطلاح به یک موضوع اشاره دارند و تفاوتی در استفاده ندارند.\nUUIDها یک عدد صحیح 128 بیتی هستند که اگر طبق روش‌های استاندارد تولید شوند، بدون آنکه به یک نهاد ثبت‌کننده مرکزی یا هماهنگی با سایر تولیدکننده‌های UUID برای تایید یکتایی نیاز داشته باشند، عملا یکتا خواهند بود. اگرچه احتمال اینکه یک UUID تکراری باشد، صفر نیست، اما آنقدر به صفر نزدیک است که می‌توان از آن چشم‌پوشی نمود. بنابراین هر کسی می‌تواند یک UUID ایجاد کند و از آن برای شناسایی موجودیتی استفاده کند و اطمینان داشته باشد که شناسه‌ای که تولید کرده ‌است با شناسه‌هایی که قبلا تولید شده یا بعدا تولید خواهد شد، تداخلی ندارد. اطلاعاتی که بوسیله UUIDها توسط موجودیت‌های مستقل برچسب‌گذاری شده‌اند می‌توانند بعدا با یکدیگر ادغام شده و در یک بانک اطلاعاتی قرار گیرند، بدون آنکه نیاز به از بردن تداخل‌های بین شناسه‌ها شود. UUIDها توسط Open Software Foundation (OSF) که بخشی از Distributed Computing Environment (DCE) است استانداردسازی شده‌اند. UUIDها در سال 1996 به عنوان بخشی از استاندارد ISO/IEC 11578:1996 \u0026ldquo;Information technology – Open Systems Interconnection – Remote Procedure Call (RPC)” و همچنین در سال 2005 نیز در استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8:2005 مستندسازی شده‌اند. همچنین Internet Engineering Task Force (IETF) با انتشار Standards-Track RFC 4122 که از نظر فنی با استاندارد ITU-T Rec. X.667 | ISO/IEC 9834-8 برابر است مستندات مربوط به UUIDها منتشر کرده است. در شیوه متعارف نمایش متنی، شانزده بایت یک شناسه GUID توسط 32 رقم هگزادسیمال (مبنای 16) که در 5 گروه که توسط خط فاصله از یکدیگر جدا شده‌اند در قالب 12-4-4-4-8 که در مجموع 36 کاراکتر (32 کاراکتر الفبایی و چهار خط فاصله) را تشکیل می‌دهد، نشان داده می‌شوند.\n1xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx نمونه 1\n1123E4567-E89B-12D3-A456-426614174000 نمونه 2\n1B4D0257C-BE19-4800-BA11-A09AC2561898 UUIDها دارای سه نوع و پنج نسخه می‌باشند. چهار بیت از رقمی که با M نشان داده شده ‌است، نسخه UUID و رقمی که با N نشان داده شده ‌است، نوع UUID را مشخص می‌کند.\n1xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx در نمونه 1، مقدار M برابر یک و مقدار N برابر a است، به این معنی است که نوع UUID از نوع یک، و نسخه آن نیز ۱ می‌باشد. در نمونه 2، مقدار M برابر 4 و مقدار N برابر b است، به این معنی که نوع UUID از نوع یک و نسخه آن 4 می‌باشد.\nانواع UUID نوع صفر - N = 0..7 برای سازگاری با سیستم قدیمی قالب UUID 1.5 سامانه محاسبات شبکه‌ایApollo در سال 1988 تعریف شده ‌است. در این قالب، 6 بایت اول زمان با طول 48 بیت است (تعداد واحدهای 4 میلی ثانیه از 1 ژانویه 1980 UTC). دو بایت بعدی رزرو شده است و بایت بعدی نوع آدرس‌دهی در شبکه Apollo است. هفت بایت آخر نیز یک شناسه میزبان 56 بیتی است که با توجه به نوع آدرس‌دهی تعیین می‌شود.\nنوع یک - N = 8..b این نوع در استاندارد RFC 4122/DCE 1.1 UUIDs ارجاع داده شده است و نوع رایج UUID می‌باشد.\nنوع دو - N = c..d این نوع که با عنوان GUID توسط شرکت مایکروسافت مطرح شده است اولین بار توسط این شرکت در سیستم عامل ویندوز مورد استفاده قرار گرفته است. نوع یک و دو در نمایش رشته‌ای مشابه هم هستند و تنها در بیت مربوط به نوع باهم متفاوت هستند اما در نمایش دودویی در روش نگهداری نیز باهم متفاوت هستند. در نوع یک از ترتیب بایت big-endian استفاده می‌شود در حالی که در نوع دو از ترتیب بایت little-endian استفاده شده است.\nنوع رزرو شده - N = e..f این بازه برای استفاده در آینده رزرو شده است.\nنسخه های UUID نسخه یک – زمان و آدرس MAC در این نسخه از زمان سیستم و آدرس MAC کارت شبکه که منحصر به فرد برای تولید UUID استفاده می‌شود. با داشتن UUID نسخه 1 با استخراج مقدار timestamp می‌توانید به این موضوع پی ببرید که این UUID چه زمانی تولید شده است. قالب متعارف UUIDهای مبتنی بر زمان به صورت زیر است:\nنام اندازه (بایت) طول (هگزادسیمال) محتوا time_low 4 8 عدد صحیحی که ۳۲ بیت پایینی زمان است time_mid 2 4 عدد صحیحی که ۱۶ بیت میانی زمان است time_hi_and_version 2 4 ۴ بیت پرارزش، نسخه را مشخص کرده و ۱۲ بیت دیگر ۱۲ بیت بالایی زمان است clock_seq_hi_and_res clock_seq_low 2 4 بیت‌های ۱ تا ۳ پرارزش نوع UUID و۱۳ تا ۱۵ بیت باقی مانده توالی ساعت است (clock sequence) node 6 12 شناسه گره ۴۸ بیتی نسخه دو - زمان و آدرس MAC و نسخه امنیتی DCE این نسخه به صورت خاص در استاندارد RFC 4122 تعریف نشده است و عمومیت ندارد. مشابه نسخه 1 است با این تفاوت که 4 بایت ابتدایی از timestamp با POSIX UID کاربر و بایت پر ‌ارزش توالی ساعت با POSIX UID دامنه جایگزین شده است.\nنسخه سه – MD5 hash و Namespace در این نسخه برای تولید UUID از Hash نمودن نام و شناسه Namespace توسط الگوریتم MD5 استفاده می‌شود. شناسه فضای نام می‌بایست خود منحصر به فرد باشد. مانند آدرس‌ها، نام‌های دامنه، شناسه موجودیت‌ها و نام‌های متمایز X.500 می‌توانند به عنوان فضای نام انتخاب شوند.\nنسخه چهار – تصادفی در این نسخه از اعداد تصادفی برای تولید UUID استفاده می‌شود. از 128 بیت، 6 بیت برای نوع و نسخه UUID رزرو شده و مابقی 122 بیت به صورت تصادفی مقدار می‌گیرند که 2 به توان 122 احتمال را شامل می‌شود. از روش های متفاوتی برای تولید اعداد تصادفی در این نسخه استفاده می‌شود و استاندارد مشخصی در این زمینه وجود ندارد.\nنسخه پنج - SHA-1 hash و Namespace مشابه نسخه 3 است با این تفاوت که از الگوریتم SHA-1 به جای MD5 برای Hash نمودن استفاده می‌شود.\nUUID خالی یا Nil UUID برای UUID یک مقدار خالی یا تهی در نظر گرفته شده است که مقدار آن 00000000-0000-0000-0000-000000000000 می‌باشد.\nصحت یکتایی UUID برخورد (Collisions) هنگامی رخ می‌دهد که یک UUID بیش از یک بار ایجاد شده و به مراجع مختلف اختصاص داده شود. در مورد UUIDهای نسخه 1 و نسخه 2 که با استفاده از آدرس‌های MAC کارت‌های شبکه که منحصر به فرد هستند ساخته شده‌اند، فقط زمانی که پیاده‌سازی استانداردها متفاوت باشد یا ایراداتی در آن وجود داشته باشد احتمال برخورد وجود دارد.\nبرخلاف نسخه 1 و نسخه 2 UUID که از آدرس‌های MAC منحصر به فرد کارت‌های شبکه استفاده می‌کنند، در نسخه 1 و 2 UUID تصادفی و نسخه 3 و 5 که مبتنی بر Hash هستند و نسخه 4 UUID تصادفی، احتمال برخورد وجود دارد. البته با احتمال بسیار کمی که به طور معمول قابل چشم پوشی است. این احتمال را می‌توان دقیقا بر اساس تجزیه و تحلیل پارادوکس تولد محاسبه کرد.\nبه عنوان مثال، تعداد UUIDهای نسخه 4 تصادفی که باید ایجاد شوند تا به احتمال 50٪ حداقل یک برخورد باید تولید شود برابر 2.71 کوئین تیلیون است. این عدد معادل تولید 1 میلیارد UUID در ثانیه برای حدود 85 سال است. فایلی که حاوی این تعداد UUID باشد، با 16 بایت در هر UUID، تقریباً 45 اگزا بایت خواهد بود. احتمال یافتن نسخه تکراری در نسخه 103 تریلیون نسخه 4 UUID یک در میلیارد است.\n","date":"Feb 5, 2017","img":"","permalink":"/posts/uuid-guid-info/","series":[],"tags":["UUID","GUID"],"title":"شناسه منحصر به فرد جهانی (UUID) چیست؟"},{"categories":["General"],"content":"آی‌پی IP اختصار عبارت Internet Protocol است که مدل فنی ارسال و دریافت بسته‌ها در اینترنت را به همراه آدرس فرستنده و گیرنده در شبکه‌ی اینترنت یا هر شبکه‌ی کامپیوتری مشخص می‌کند. در حال حاضر دو نسخه برای IP وجود دارد که شامل IPv4 و IPv6 است.\nIPv6 که Internet Protocol Next Generation نیز خوانده می‌شود، جدیدترین پروتکل اینترنت برای اختصاص آدرس IP است که برای تکمیل و در نهایت جایگزین شدن IPV4 در نظر گرفته شده است. در حال حاضر تا زمان مقتضی شاهد استفاده از هر دو پروتکل به‌صورت هم‌زمان خواهیم بود تا اینکه در نهایت IPv6 به‌صورت کامل جای این پروتکل را بگیرد. IPv6 به این علت طراحی شده است تا علاوه بر داشتن آدرس‌های بیشتر برای اتصال دستگاه‌های بیشتر در مقایسه با IPv4، ظرفیت انتقال اطلاعات در شبکه اینترنت یا همان ترافیک را افزایش دهد. IPv4 یک آدرس اینترنتی 32 بیتی است که به‌صورت اعداد ده‌دهی (دستگاه اعداد مبنای ۱0) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv4 به‌صورت چهار دسته (Octet) 8 بیتی نوشته می‌شود که توسط یک نقطه از هم جدا می‌شوند. هر یک از چهار دسته عدد سه‌تایی می‌تواند مقادیر صفر تا 255 را داشته باشد. پس برای هر بخش می توان 256 رقم (2 به توان 8) را در نظر گرفت که با این حساب 2 به توان 32 یا 4294967296 رقم خواهیم داشت. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv4 است.\n1172.16.110.1 IPv6 یک آدرس اینترنتی 128 بیتی است که به‌صورت اعداد هگزادسیمال استاندارد (دستگاه اعداد مبنای 16) در قالب یک رشته نمایش داده می‌شود. یک آدرس اینترنتی مبتنی بر IPv6 به‌صورت هشت دسته (Octet) 16 بیتی نوشته می‌شود که توسط یک کالِن از هم جدا می‌شوند. هر یک از هشت دسته 8 بیتی می‌تواند مقادیر 0000 تا FFFF را داشته باشد. پس برای هر بخش می‌توان 65,536 رقم (2 به توان 16) را در نظر گرفت که با این حساب 2 به توان 128 یا 340,282,366,920,938,463,463,374,607,431,768,211,456 عدد خواهیم داشت که حدود 7,922,816,251,426,433,759,354 برابر بیشتر از IPv4 می‌باشد. برای مثال آدرس زیر یک آدرس اینترنتی مبتنی بر IPv6 است.\n165b3:b834:45a3:0000:0000:762e:0270:5224 در IPv6 بخش‌هایی که تمام رقم‌های آن صفر می‌باشند را می‌توان حذف نمود و به جای آن‌ها از کاراکتر : استفاده کرد. به عنوان مثال آدرس‌های زیر مشابه هم هستند:\n12001:cdba:0000:0000:0000:0000:3257:9652 2 32001:cdba:0:0:0:0:3257:9652 4 52001:cdba::3257:9652 ","date":"Jan 3, 2017","img":"","permalink":"/posts/ip-info/","series":[],"tags":["IP"],"title":"آدرس آی‌پی (IP) چیست؟"},{"categories":["General"],"content":"برنامه‌نویس‌های موفق عادات مشترکی دارند که آن ها را از جهات مختلف در یک گروه قرار می‌دهد. اگر شما هم یک برنامه‌نویس هستید شاید شما هم بسیاری از این عادات را داشته باشید.\nیک برنامه‌نویس موفق هیچ وقت سر وقت در محل کارش پیدایش نمی‌شود! همیشه عجله دارد ولی مرد یک دو سه نیست. معنای نیمه شب‌ها برای یک برنامه‌نویس موفق با نیمه شب انسان‌های عادی تفاوت دارد. نیمه شب برای یک برنامه‌نویس یعنی ۱۰ صبح برای یک انسان عادی! یک برنامه‌نویس همیشه تعدادی لغات تخصصی در آستین دارد که می‌تواند با سر هم کردن آن‌ها، دیگران را گیج کند. برای یک برنامه‌نویس هیچ راه‌حلی بالاتر از Restart کردن وجود ندارد. برای یک برنامه‌نویس موفق یا نام بیل گیتس مقدس است و معبدش ویندوز می‌باشد یا خدایش لینوس توروالدز است و معبدش لینوکس. یک برنامه‌نویس موفق فقط و فقط با لپ‌تاپ خود عشق بازی می‌کند. یک برنامه‌نویس موفق می‌داند طعم قهوه وقتی سیگاری بر گوشه‌ی لب خود دارد چه مفهومی دارد. یک برنامه‌نویس موفق اکثراً قهوه و چایی ولرم می‌نوشد. برنامه‌نویسی موفق است که کلمه‌ی نظم را خودش معنا کرده باشد. اتاق و محل کار یک برنامه‌نویس موفق هیچ‌گاه مرتب نیست بلکه تابع معنای نظم زندگی‌اش است. یک برنامه‌نویس موفق می‌داند که فست‌فود تنها غذای جسم اوست و یک موزیک متالیکا بخصوص مال ۱۹۹۲ غذای روحش. یک برنامه‌نویس موفق به ندرت عصبانی می‌شود ولی وای به آن لحظه که عصبانی شود\u0026hellip; یک برنامه‌نویس موفق دختران زیادی را در زندگی خود داشته است ولی فقط یکی از آن‌ها بوده که او را می‌فهمیده ولی او اکنون نیست. یک برنامه‌نویس موفق در هر لحظه می‌تواند کل کل کند و معنای باخت را هرگز نچشد. یک برنامه‌نویس موفق هیچگاه خواب زن‌های برهنه را نمی‌بیند. یک برنامه‌نویس موفق همیشه مشکوک است ولی خود را آرام نشان می‌دهد. یک برنامه‌نویس موفق همیشه با عرفان و فلسفه لاس می‌زند ولی همیشه هم فاصله‌اش را با آن حفظ می‌کند. یک برنامه‌نویس موفق اوج زندگیش را در سن ۱۸ تا ۲۶ سالگی می‌داند. برنامه‌نویس موفق همه‌ی بچه‌ها را دوست دارد البته تا وقتی که گریه نکنند. فقط یک برنامه‌نویس موفق است که معنای ۵۴ ساعت بیداری و کار مداوم را درک می‌کند. یک برنامه‌نویس موفق همیشه تنهاست. زندگی او در برنامه‌هایش خلاصه شده است. ۴۰ سالگی زمان بازنشستگی یک برنامه‌نویس موفق است، یعنی زمانی که به خود می‌گوید: می‌خواهم زن بگیرم! مردم برای یک برنامه‌نویس موفق نقش ابلهانی را دارند که فقط می‌توانند سفارش پروژه‌ای را بدهند که خودشان هم دقیقا نمی‌دانند هدف‌شان از سفارش آن پروژه چیست؟ یک برنامه‌نویس موفق زود از دختران خسته می‌شود، گاهی در تنهایی فقط به آنها فکر می‌کند. کابوس یک برنامه‌نویس موفق، شرکت در جلسه‌ای با حضور کاربران عوام است و بلاهای طبیعیش هم بهم ریختن دسکتاپش است. اینترنت را قطع کنید تا ببینید یک برنامه‌نویس موفق چه رفتارهای ناهنجاری انجام می‌دهد. فقط یک برنامه‌نویس موفق است که می‌تواند بدترین دعوا را با مدیر عامل داشته باشد ولی ککش هم نگزد. یک برنامه‌نویس موفق OOP را هضم کرده و با SOA رقص تانگو می‌کند. خب! کدومتون یک برنامه‌نویس موفق هستید؟؟؟ :)\n","date":"Dec 11, 2015","img":"","permalink":"/posts/successful-programmer/","series":[],"tags":["Programmer"],"title":"چگونه یک برنامه‌نویس موفق شویم؟"},{"categories":["General","SQL"],"content":"به منظور استفاده از جداول نمونه یکسان در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه اسکریپت‌های مربوط به ایجاد جداول و ثبت داده‌های پیش فرض آن را برای هر نوع بانک اطلاعاتی قرار دهم. در این مطلب اسکریپت مربوط به بانک اطلاعاتی Oracle قرار داده شده است.\nجدول regions 1CREATE TABLE regions ( 2 region_id NUMBER(10) PRIMARY KEY, 3 region_name VARCHAR2(25) DEFAULT NULL 4); 5 6INSERT INTO regions(region_id,region_name) VALUES (1,\u0026#39;Europe\u0026#39;); 7INSERT INTO regions(region_id,region_name) VALUES (2,\u0026#39;Americas\u0026#39;); 8INSERT INTO regions(region_id,region_name) VALUES (3,\u0026#39;Asia\u0026#39;); 9INSERT INTO regions(region_id,region_name) VALUES (4,\u0026#39;Middle East and Africa\u0026#39;); جدول countries 1CREATE TABLE countries ( 2\tcountry_id CHAR(2) PRIMARY KEY, 3\tcountry_name VARCHAR2(40) DEFAULT NULL, 4\tregion_id NUMBER(10) NOT NULL, 5\tFOREIGN KEY (region_id) REFERENCES regions (region_id) ON DELETE CASCADE 6); 7 8INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;AU\u0026#39;,\u0026#39;Australia\u0026#39;,3); 9INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;AR\u0026#39;,\u0026#39;Argentina\u0026#39;,2); 10INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;BE\u0026#39;,\u0026#39;Belgium\u0026#39;,1); 11INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;BR\u0026#39;,\u0026#39;Brazil\u0026#39;,2); 12INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CA\u0026#39;,\u0026#39;Canada\u0026#39;,2); 13INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CH\u0026#39;,\u0026#39;Switzerland\u0026#39;,1); 14INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;CN\u0026#39;,\u0026#39;China\u0026#39;,3); 15INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;DE\u0026#39;,\u0026#39;Germany\u0026#39;,1); 16INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;DK\u0026#39;,\u0026#39;Denmark\u0026#39;,1); 17INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;EG\u0026#39;,\u0026#39;Egypt\u0026#39;,4); 18INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;FR\u0026#39;,\u0026#39;France\u0026#39;,1); 19INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;HK\u0026#39;,\u0026#39;HongKong\u0026#39;,3); 20INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IL\u0026#39;,\u0026#39;Israel\u0026#39;,4); 21INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IN\u0026#39;,\u0026#39;India\u0026#39;,3); 22INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;IT\u0026#39;,\u0026#39;Italy\u0026#39;,1); 23INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;JP\u0026#39;,\u0026#39;Japan\u0026#39;,3); 24INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;KW\u0026#39;,\u0026#39;Kuwait\u0026#39;,4); 25INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;MX\u0026#39;,\u0026#39;Mexico\u0026#39;,2); 26INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;NG\u0026#39;,\u0026#39;Nigeria\u0026#39;,4); 27INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;NL\u0026#39;,\u0026#39;Netherlands\u0026#39;,1); 28INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;SG\u0026#39;,\u0026#39;Singapore\u0026#39;,3); 29INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;UK\u0026#39;,\u0026#39;United Kingdom\u0026#39;,1); 30INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;US\u0026#39;,\u0026#39;United States of America\u0026#39;,2); 31INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;ZM\u0026#39;,\u0026#39;Zambia\u0026#39;,4); 32INSERT INTO countries(country_id,country_name,region_id) VALUES (\u0026#39;ZW\u0026#39;,\u0026#39;Zimbabwe\u0026#39;,4); ","date":"Jan 8, 2014","img":"","permalink":"/posts/oracle-sample-tables/","series":[],"tags":["Oracle","SQL"],"title":"نمونه جدول‌های Oracle"},{"categories":["General"],"content":"در این مطلب کتاب‌های معتبر مرتبط با برنامه‌نویسی و بانک‌های اطلاعاتی را برای دانلود قرار دادم. این مطلب به مرور به‌روزرسانی می‌شود و کتاب‌های بیشتری به آن اضافه می‌شود.\nJava How to Program, 11/e, Early Objects by Paul Deitel, Harvey Deitel Pearson Head First Java, A Brain-Friendly Guide, 3rd Edition by Kathy Sierra, Bert Bates, Trisha Gee - O\u0026rsquo;Reilly Media Design Patterns: Elements of Reusable Object-Oriented Software, by Erich Gamma, John Vlissides, Ralph Johnson, Richard Helm ","date":"Jan 6, 2014","img":"","permalink":"/posts/books/","series":[],"tags":[],"title":"کتابخانه"},{"categories":["General"],"content":"به منظور ترجمه یکسان کلمات انگلیسی در مطالب این وبلاگ تصمیم گرفتم در یک مطلب جداگانه ترجمه کلمات (یا معادل فارسی مورد استفاده) را قرار دهم.\nargument - آرگومان assembly - اسمبلی binary - باینری call specification - مشخصات فراخوانی character - نویسه، کاراکتر، حرف charset - مجموعه حروف checklist - چک لیست class - کلاس clause - عبارت code - کد collision - برخورد، تصادم comma - کاما compatibility - تطبیق‌پذیری compile - کامپایل compiler - کامپایلر database - بانک اطلاعاتی design pattern - الگوی طراحی directory - دایرکتوری file - فایل function - تابع glyph - شکل load - بارگذاری method - متد namespace - فضای نام object - شی query - پرس‌و‌جو reusable - قابل استفاده مجدد schema - اسکیما scope - حوزه stored procedure - روال‌ ذخیره‌شده trustworthy - اعتماد\n","date":"Jan 5, 2014","img":"","permalink":"/posts/dict/","series":[],"tags":[],"title":"واژه نامه"},{"categories":["General"],"content":"سیستم لایتنر یک ابزار یادگیری مفید است که باعث ثبت اطلاعات در حافظه بلندمدت افراد می‌شود. اجرای این روش به‌واسطه یک جعبه چندبخشی ساده و چند فلش‌کارت انجام می‌شود. این تکنیک شامل مرور و بررسی مجموعه‌ای از فلش‌کارت‌ها در فواصل زمانی منظم است.\nدر حقیقت فرد برای حفظ کردن بهتر آموخته‌ها موظف است با در نظر گرفتن یک سیستم زمان‌بندی مشخص، مرور مطالب جدید را در فاصله‌های زمانی مشخص انجام دهد. چرا که این سیستم برای اولویت‌بندی مطالبی که نیاز به مرور مجدد دارند بسیار مفید واقع می‌شود. سیستم لایتنر برای اولین‌بار در سال 1972 توسط یک روزنامه‌نگار آلمانی به نام سباستین لایتنر معرفی شد. او جزو اولین کسانی بود که در روش پیشنهادی خود با استفاده از تکرار آموخته‌ها در فاصله‌های زمانی مشخص، به فرد کمک می‌کرد تا بتواند مطالب را در حافظه بلندمدت خود ثبت کند. این تکنیک پرطرف‌دار هنوز هم یک تمرین عالی برای تکرار و مرور آموخته‌ها محسوب می‌شود. برای استفاده از سیستم لایتنر به یک جعبه لاینتر نیاز داریم. این جعبه مطابق شکل زیر به 5 بخش مجزا بخش‌بندی می‌شود. پیش از اینکه به سراغ طرز کار جعبه لایتنر برویم، به یاد داشته باشید که هر خانه شامل چند بخش داخلی است و عمر فلش‌کارت‌های هر خانه از جعبه لایتنر به‌صورت زیر انجام می‌شود: خانه اول یک‌دسته‌ای و یک‌روزه است؛ این یعنی هر فلش‌کارتی که در این خانه قرار می‌دهید، تنها یک روز بعد باید مرور شود. خانه دوم دودسته‌ای یا دوروزه است؛ یعنی دو روز زمان نیاز است تا فلش‌کارت‌های این خانه مرور شوند. خانه سوم چهاردسته‌ای یا چهارروزه است؛ یعنی چهار روز طول می‌کشد تا فلش‌کارت‌های این خانه مرور و تکرار شوند. خانه چهارم هشت‌روزه است یعنی 8 روز زمان نیاز دارید تا بتوانید کارت‌های این بخش را مرور و به خانه پنجم منتقل کنید. خانه پنجم شانزده‎روزه است؛ این یعنی عمر کارت‌های این خانه 16 روز بوده و کارت‌ها باید 16 روز در این بخش بمانند تا به سراغ مرور آنها بروید. اگر می‌خواهیم از جعبه لایتنر برای یادگیری زبان انگلیسی استفاده کنیم، اولین قدم این است که در یک سمت هر فلش‌کارت سوال، واژه، مثال یا نکته موردنظر خود را یادداشت کنیم و در سمت دیگر فلش‌کارت جواب، معنا و یا نکته‌ای که سعی در یادگیری آن را داریم بنویسیم. نحوه کار با جعبه لایتنر روز اول روز اول فلش‌کارتی که نوشته‌ایم را برمی‌داریم و سعی می‌کنیم مطلب آن را به حافظه بسپاریم. پس از اینکه از یادگیری مطمئن شدیم، آن را در باریک‌ترین خانه (خانه یک‌سانتی‌متری) قرار می‌دهیم. دقت کنید باید فلش‌کارت‌ها را به‌گونه‌ای در جعبه قرار دهیم که صورت سوال رو به شما باشد و پاسخ از دید پنهان گردد. روز دوم روز دوم تمامی کارت‌های خانه اول را برمی‌داریم. بدون اینکه به جواب نگاه کنیم، سعی می‌کنیم پس از چند ثانیه پاسخ هر سوال را به‌خاطر بیاوریم. اگر توانستیم به سوال کارتی پاسخ درست بدهیم، آن را به خانه دوم (خانه 5 سانتی‌متری) منتقل می‌کنیم. اگر هم موفق به این کار نشدیم، یک بار دیگر پاسخ صحیح را می‌بینیم و کارت را در همان خانه اول می‌گذاریم. روز سوم در روز سوم به کارت‌های خانه دوم کاری نداریم. در این روز تنها سعی می‌کنیم یک‌‌ بار دیگر کارت‌های خانه اول را برداریم. شانس خود را برای یادآوری پاسخ صحیح امتحان می‌کنیم. چنانچه بتوانیم مطلب را به‌خوبی به یاد بیاوریم، باید کارت را به خانه دوم منتقل کنیم. در این مرحله باید فلش‌کارت‌های جدیدی که به خانه دوم وارد می‌شوند را به‌واسطه یک کاغذ رنگی (ترجیحاً کمی بلندتر از فلش‌کارت‌ها) از فلش‌کارت‌های قدیمی‌ترِ خانه دوم جدا کنیم. روز چهارم روز چهارم به سراغ خانه دوم می‌رویم؛ زیرا ظرفیت این خانه دودسته‌ای پر شده؛ پس ابتدا فلش‌کارت‌های قدیمی‌تر را بر می‌داریم که دو روز از مرور آنها گذشته است. چند ثانیه برای به یاد آوردن مطلب به خود زمان می‌دهیم، اگر موفق شدیم کارت‌ها را به خانه سوم منتقل می‌کنیم. اگر موفق نشدیم آن‌ها را به خانه اول بر می‌گردانیم تا روز بعد دوباره آن را مرور کنیم. حال فلش‌کارت‌هایی که دیروز در خانه دوم قرار داده بودیم، جای خالی فلش‌کارت‌های منتقل شده به خانه سوم را می‌گیرند و این بار کاغذ رنگی را پشت آن‌ها قرار می‌دهیم. پشت فلش‌کارت‌های خانه سوم هم کاغذ رنگی قرار می‌دهیم. در گام بعدی به سراغ فلش‌کارت‌های خانه اول می‌رویم، کارت‌هایی که پاسخ آنها را به یاد می‌آوریم را در خانه دوم گذاشته و پشت آنها یک کاغذ رنگی قرار می‌دهیم. اگر هم پاسخ را نمی‌دانستیم، کارت‌ها را مجدداً در همان خانه اول قرار دهیم. روز پنجم: روز پنجم کارت‌هایی که در خانه دوم قرار دارند و دو روز از یادآوری آنها گذشته است را برمی‌داریم. اگر مطلب را بلد بودیم کارت را به خانه سوم منتقل می‌شوند، اگر هم پاسخ صحیح را نمی‌دانستیم کارت را همراه‌ با کارت‌های جدیدی که همان روز می‌نویسیم در خانه اول بگذاریم. برگه‌هایی که در خانه دوم قرار دارند را کمی جلوتر گذاشته و کاغذ رنگی را پشت آن قرار دهیم. فلش‌کارت‌های جدید (خانه اول) را می‌خوانیم، اگر بلد بودیم به خانه دوم و پشت کاغذ رنگی قرار می‌دهیم، در غیر این صورت آن‌ها را در همان خانه اول باقی می‌گذاریم. به یاد داشته باشید در این مرحله نباید کارت‌های خانه سوم را جابه‌جا کنیم؛ چون تا زمانی که هر 4 بخش این خانه تکمیل نشوند، نباید به سراغ مرور آنها برویم. روز ششم و هفتم: در این دو روز مانند روز پنجم عمل می‌کنیم تا ظرفیت هر چهار بخش خانه سوم تکمیل شود. روز هشتم: در این روز ظرفیت هر چهار بخشِ خانه سوم تکمیل شده، پس وقت آن رسیده تا کارت‌های قدیمی‌تر به خانه چهارم وارد شوند. فلش‌کارت‌ها این بخش را برمی‌داریم و مرور می‌کنیم؛ هر کدام را که بلد بودیم به خانه چهارم منتقل کرده و یک کاغذ رنگی را پشت این دسته کارت قرار می‌دهیم. اگر هم نتوانستیم به سوال هر کارت پاسخ صحیح بدهیم، آن را به همراهِ کارت‌های جدید به خانه اول می‌فرستیم تا روند مرور آن از ابتدا آغاز شود. در مورد کارت‌های خانه دوم هم روال قبلی را تکرار کنیم. نکات مهم هر فلش‌کارتی که بلد نبودیم را به همراهِ کارت‌های جدید در خانه اول قرار می‌دهیم. مرور کارت‌های قدیمی‌تر، هنگام تکمیل ظرفیت بخش‌های داخلی هر خانه مهم‌ترین نکته‌ای است که باید در استفاده از جعبه لایتنر لحاظ کنیم. اگر مطلب کارت را بلد بودیم، آن را به بخش بعدی منتقل می‌کنیم و یک کاغذ رنگی را پشت آن می‌گذاریم. این روند را باید تا آخرین بخش خانه پنجم تکرار کنید. هر زمان کارتی از خانه پنجم جعبه خارج شد، آن کارت جزو آموخته‌های حافظه بلندمدت ما قرار گرفته و به این راحتی فراموش نمی‌شود. ","date":"Aug 2, 2010","img":"","permalink":"/posts/leitner-system/","series":[],"tags":[],"title":"سیستم لایتنر"},{"categories":null,"content":"","date":"Jan 1, 0001","img":"","permalink":"/contact/","series":null,"tags":null,"title":"تماس با من"}]